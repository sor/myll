//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\sor\Documents\Visual Studio 2012\Projects\MyLangParser\MyLang.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace MyLang {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class MyLangParser : Parser {
	public const int
		T__31=1, T__30=2, T__29=3, T__28=4, T__27=5, T__26=6, T__25=7, T__24=8, 
		T__23=9, T__22=10, T__21=11, T__20=12, T__19=13, T__18=14, T__17=15, T__16=16, 
		T__15=17, T__14=18, T__13=19, T__12=20, T__11=21, T__10=22, T__9=23, T__8=24, 
		T__7=25, T__6=26, T__5=27, T__4=28, T__3=29, T__2=30, T__1=31, T__0=32, 
		COMMENT=33, STRING_LIT=34, CHAR_LIT=35, PTR_TO_ARY=36, TRP_POINT=37, DBL_POINT=38, 
		DBL_LBRACK=39, DBL_RBRACK=40, DBL_AMP=41, DBL_PLUS=42, DBL_MINUS=43, RARROW=44, 
		LSHIFT=45, SCOPE=46, AT_BANG=47, AT_QUEST=48, AT_PLUS=49, AT_LBRACK=50, 
		LBRACK=51, RBRACK=52, LCURLY=53, RCURLY=54, LPAREN=55, RPAREN=56, AUTOINDEX=57, 
		AT=58, AMP=59, STAR=60, SLASH=61, MOD=62, PLUS=63, MINUS=64, SEMI=65, 
		COLON=66, COMMA=67, POINT=68, EQ=69, NEQ=70, LTEQ=71, GTEQ=72, LT=73, 
		GT=74, ASSIGN=75, UNSIGNED=76, SIGNED=77, VOID=78, BOOL=79, CHAR=80, CHAR16=81, 
		CHAR32=82, WCHAR=83, SHORT=84, INT=85, LONG=86, FLOAT=87, DOUBLE=88, NS=89, 
		VOLATILE=90, CONST=91, MUTABLE=92, SQRT=93, UNION=94, CLASS=95, STRUCT=96, 
		FUNC=97, METH=98, ENUM=99, PROP=100, FIELDS=101, FIELD=102, OPERATOR=103, 
		VAR=104, FOR=105, TIMES=106, IF=107, ELSE=108, RETURN=109, ID=110, FLOAT_LIT=111, 
		INTEGER_LIT=112, NL=113, WS=114, NEWLINES=115, COMMENTS=116;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'poly'", "'force'", "'nothing'", "'*='", "'ctor'", "'pod'", 
		"'throw'", "'.*'", "'|='", "'new'", "'nop'", "'|'", "'!'", "'sizeof'", 
		"'<<='", "'->*'", "'-='", "'**'", "'&='", "'?'", "'>>='", "'break'", "'+='", 
		"'^='", "'permit'", "'static'", "'delete'", "'^'", "'||'", "'%='", "'/='", 
		"'~'", "COMMENT", "STRING_LIT", "CHAR_LIT", "'[*]'", "'...'", "'..'", 
		"'[['", "']]'", "'&&'", "'++'", "'--'", "'->'", "'<<'", "'::'", "'@!'", 
		"'@?'", "'@+'", "'@['", "'['", "']'", "'{'", "'}'", "'('", "')'", "AUTOINDEX", 
		"'@'", "'&'", "'*'", "'/'", "'%'", "'+'", "'-'", "';'", "':'", "','", 
		"'.'", "'=='", "'!='", "'<='", "'>='", "'<'", "'>'", "'='", "'unsigned'", 
		"'signed'", "'void'", "'bool'", "'char'", "'char16_t'", "'char32_t'", 
		"'wchar_t'", "'short'", "'int'", "'long'", "'float'", "'double'", "'namespace'", 
		"'volatile'", "'const'", "'mutable'", "'sqrt'", "'union'", "'class'", 
		"'struct'", "'func'", "'meth'", "'enum'", "'prop'", "'fields'", "'field'", 
		"'operator'", "'var'", "'for'", "'times'", "'if'", "'else'", "'return'", 
		"ID", "FLOAT_LIT", "INTEGER_LIT", "NL", "WS", "NEWLINES", "COMMENTS"
	};
	public const int
		RULE_scope_OP = 0, RULE_post_OP = 1, RULE_pre_OP = 2, RULE_assign_OP = 3, 
		RULE_pow_OP = 4, RULE_mult_OP = 5, RULE_add_OP = 6, RULE_shift_OP = 7, 
		RULE_bitand_OP = 8, RULE_bitxor_OP = 9, RULE_bitor_OP = 10, RULE_and_OP = 11, 
		RULE_or_OP = 12, RULE_mem_OP = 13, RULE_memptr_OP = 14, RULE_order_OP = 15, 
		RULE_equal_OP = 16, RULE_preOpExpr = 17, RULE_castExpr = 18, RULE_sizeofExpr = 19, 
		RULE_newExpr = 20, RULE_deleteExpr = 21, RULE_expr = 22, RULE_exprs = 23, 
		RULE_tt_exp = 24, RULE_prog = 25, RULE_toplevel = 26, RULE_attrib = 27, 
		RULE_id_opt_value = 28, RULE_class_expr = 29, RULE_class_extened_expr = 30, 
		RULE_field_expr = 31, RULE_vars_decl = 32, RULE_prop_expr = 33, RULE_idOrLit = 34, 
		RULE_parameter = 35, RULE_parameters = 36, RULE_initializationList = 37, 
		RULE_argumentList = 38, RULE_ctor_decl = 39, RULE_funcmeth_decl = 40, 
		RULE_operator_decl = 41, RULE_statements = 42, RULE_statement = 43, RULE_anyType = 44, 
		RULE_typePtr = 45, RULE_typeQualifier = 46, RULE_signQualifier = 47, RULE_advancedType = 48, 
		RULE_idTplType = 49, RULE_anyTypeOrConsts = 50, RULE_anyTypeOrConst = 51, 
		RULE_basicType = 52, RULE_characterType = 53, RULE_integerType = 54, RULE_floatingType = 55, 
		RULE_anyTypeCS = 56, RULE_expr_old = 57, RULE_comment = 58;
	public static readonly string[] ruleNames = {
		"scope_OP", "post_OP", "pre_OP", "assign_OP", "pow_OP", "mult_OP", "add_OP", 
		"shift_OP", "bitand_OP", "bitxor_OP", "bitor_OP", "and_OP", "or_OP", "mem_OP", 
		"memptr_OP", "order_OP", "equal_OP", "preOpExpr", "castExpr", "sizeofExpr", 
		"newExpr", "deleteExpr", "expr", "exprs", "tt_exp", "prog", "toplevel", 
		"attrib", "id_opt_value", "class_expr", "class_extened_expr", "field_expr", 
		"vars_decl", "prop_expr", "idOrLit", "parameter", "parameters", "initializationList", 
		"argumentList", "ctor_decl", "funcmeth_decl", "operator_decl", "statements", 
		"statement", "anyType", "typePtr", "typeQualifier", "signQualifier", "advancedType", 
		"idTplType", "anyTypeOrConsts", "anyTypeOrConst", "basicType", "characterType", 
		"integerType", "floatingType", "anyTypeCS", "expr_old", "comment"
	};

	public override string GrammarFileName { get { return "MyLang.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }


		protected const int EOF = Eof;

	public MyLangParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class Scope_OPContext : ParserRuleContext {
		public Scope_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scope_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterScope_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitScope_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScope_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Scope_OPContext scope_OP() {
		Scope_OPContext _localctx = new Scope_OPContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_scope_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118; Match(SCOPE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Post_OPContext : ParserRuleContext {
		public Post_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_post_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPost_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPost_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPost_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Post_OPContext post_OP() {
		Post_OPContext _localctx = new Post_OPContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_post_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 120;
			_la = _input.La(1);
			if ( !(_la==DBL_PLUS || _la==DBL_MINUS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pre_OPContext : ParserRuleContext {
		public Pre_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pre_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPre_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPre_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPre_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pre_OPContext pre_OP() {
		Pre_OPContext _localctx = new Pre_OPContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_pre_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122;
			_la = _input.La(1);
			if ( !(((((_la - 13)) & ~0x3f) == 0 && ((1L << (_la - 13)) & ((1L << (T__19 - 13)) | (1L << (T__0 - 13)) | (1L << (DBL_PLUS - 13)) | (1L << (DBL_MINUS - 13)) | (1L << (AMP - 13)) | (1L << (STAR - 13)) | (1L << (PLUS - 13)) | (1L << (MINUS - 13)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assign_OPContext : ParserRuleContext {
		public Assign_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAssign_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAssign_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assign_OPContext assign_OP() {
		Assign_OPContext _localctx = new Assign_OPContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_assign_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__28) | (1L << T__23) | (1L << T__17) | (1L << T__15) | (1L << T__13) | (1L << T__11) | (1L << T__9) | (1L << T__8) | (1L << T__2) | (1L << T__1))) != 0) || _la==ASSIGN) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pow_OPContext : ParserRuleContext {
		public Pow_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pow_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPow_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPow_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPow_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pow_OPContext pow_OP() {
		Pow_OPContext _localctx = new Pow_OPContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_pow_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 126; Match(T__14);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mult_OPContext : ParserRuleContext {
		public Mult_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterMult_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitMult_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_OPContext mult_OP() {
		Mult_OPContext _localctx = new Mult_OPContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_mult_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STAR) | (1L << SLASH) | (1L << MOD))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_OPContext : ParserRuleContext {
		public Add_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAdd_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAdd_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_OPContext add_OP() {
		Add_OPContext _localctx = new Add_OPContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_add_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 130;
			_la = _input.La(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Shift_OPContext : ParserRuleContext {
		public Shift_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shift_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterShift_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitShift_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShift_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shift_OPContext shift_OP() {
		Shift_OPContext _localctx = new Shift_OPContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_shift_OP);
		try {
			State = 135;
			switch (_input.La(1)) {
			case LSHIFT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 132; Match(LSHIFT);
				}
				break;
			case GT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 133; Match(GT);
				State = 134; Match(GT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bitand_OPContext : ParserRuleContext {
		public Bitand_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitand_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBitand_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBitand_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitand_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bitand_OPContext bitand_OP() {
		Bitand_OPContext _localctx = new Bitand_OPContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_bitand_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 137; Match(AMP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bitxor_OPContext : ParserRuleContext {
		public Bitxor_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitxor_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBitxor_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBitxor_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitxor_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bitxor_OPContext bitxor_OP() {
		Bitxor_OPContext _localctx = new Bitxor_OPContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_bitxor_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 139; Match(T__4);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bitor_OPContext : ParserRuleContext {
		public Bitor_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitor_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBitor_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBitor_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitor_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bitor_OPContext bitor_OP() {
		Bitor_OPContext _localctx = new Bitor_OPContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_bitor_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141; Match(T__20);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class And_OPContext : ParserRuleContext {
		public And_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_and_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAnd_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAnd_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnd_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public And_OPContext and_OP() {
		And_OPContext _localctx = new And_OPContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_and_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 143; Match(DBL_AMP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Or_OPContext : ParserRuleContext {
		public Or_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_or_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterOr_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitOr_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOr_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Or_OPContext or_OP() {
		Or_OPContext _localctx = new Or_OPContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_or_OP);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 145; Match(T__3);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mem_OPContext : ParserRuleContext {
		public Mem_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mem_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterMem_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitMem_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMem_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mem_OPContext mem_OP() {
		Mem_OPContext _localctx = new Mem_OPContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_mem_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 147;
			_la = _input.La(1);
			if ( !(_la==RARROW || _la==POINT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Memptr_OPContext : ParserRuleContext {
		public Memptr_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memptr_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterMemptr_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitMemptr_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemptr_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Memptr_OPContext memptr_OP() {
		Memptr_OPContext _localctx = new Memptr_OPContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_memptr_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 149;
			_la = _input.La(1);
			if ( !(_la==T__24 || _la==T__16) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_OPContext : ParserRuleContext {
		public Order_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterOrder_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitOrder_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_OPContext order_OP() {
		Order_OPContext _localctx = new Order_OPContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_order_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 151;
			_la = _input.La(1);
			if ( !(((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (LTEQ - 71)) | (1L << (GTEQ - 71)) | (1L << (LT - 71)) | (1L << (GT - 71)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Equal_OPContext : ParserRuleContext {
		public Equal_OPContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equal_OP; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterEqual_OP(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitEqual_OP(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqual_OP(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Equal_OPContext equal_OP() {
		Equal_OPContext _localctx = new Equal_OPContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_equal_OP);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153;
			_la = _input.La(1);
			if ( !(_la==EQ || _la==NEQ) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreOpExprContext : ParserRuleContext {
		public Pre_OPContext pre_OP() {
			return GetRuleContext<Pre_OPContext>(0);
		}
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public PreOpExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preOpExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPreOpExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPreOpExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreOpExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PreOpExprContext preOpExpr() {
		PreOpExprContext _localctx = new PreOpExprContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_preOpExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 155; pre_OP();
			State = 156; expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CastExprContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public CastExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterCastExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitCastExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastExprContext castExpr() {
		CastExprContext _localctx = new CastExprContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_castExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158; Match(LPAREN);
			State = 159; anyType();
			State = 160; Match(RPAREN);
			State = 161; expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SizeofExprContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public SizeofExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sizeofExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterSizeofExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitSizeofExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSizeofExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SizeofExprContext sizeofExpr() {
		SizeofExprContext _localctx = new SizeofExprContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_sizeofExpr);
		try {
			State = 170;
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 163; Match(T__18);
				State = 164; expr(0);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 165; Match(T__18);
				State = 166; Match(LPAREN);
				State = 167; expr(0);
				State = 168; Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewExprContext : ParserRuleContext {
		public ExprsContext exprs() {
			return GetRuleContext<ExprsContext>(0);
		}
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public NewExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterNewExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitNewExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewExprContext newExpr() {
		NewExprContext _localctx = new NewExprContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_newExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 172; Match(T__22);
			State = 174;
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				{
				State = 173; anyType();
				}
				break;
			}
			State = 180;
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				{
				State = 176; Match(LPAREN);
				State = 177; exprs();
				State = 178; Match(RPAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteExprContext : ParserRuleContext {
		public IToken ary;
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public DeleteExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterDeleteExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitDeleteExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeleteExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeleteExprContext deleteExpr() {
		DeleteExprContext _localctx = new DeleteExprContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_deleteExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 182; Match(T__5);
			State = 185;
			_la = _input.La(1);
			if (_la==LBRACK) {
				{
				State = 183; _localctx.ary = Match(LBRACK);
				State = 184; Match(RBRACK);
				}
			}

			State = 187; expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
	 
		public ExprContext() { }
		public virtual void CopyFrom(ExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Tier17Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier17Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier17(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier17(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier17(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier100Context : ExprContext {
		public Tt_expContext tt_exp() {
			return GetRuleContext<Tt_expContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public Tier100Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier100(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier100(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier100(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenExprContext : ExprContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ParenExprContext(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterParenExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitParenExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier13Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public And_OPContext and_OP() {
			return GetRuleContext<And_OPContext>(0);
		}
		public Tier13Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier13(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier13(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier13(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier9Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Equal_OPContext equal_OP() {
			return GetRuleContext<Equal_OPContext>(0);
		}
		public Tier9Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier9(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier9(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier9(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier14Context : ExprContext {
		public Or_OPContext or_OP() {
			return GetRuleContext<Or_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier14Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier14(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier14(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier14(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier8Context : ExprContext {
		public Order_OPContext order_OP() {
			return GetRuleContext<Order_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier8Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier8(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier8(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier8(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier15Context : ExprContext {
		public Assign_OPContext assign_OP() {
			return GetRuleContext<Assign_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier15Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier15(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier15(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier15(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier7Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Shift_OPContext shift_OP() {
			return GetRuleContext<Shift_OPContext>(0);
		}
		public Tier7Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier7(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier7(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier7(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier16Context : ExprContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public Tier16Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier16(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier16(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier16(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier6Context : ExprContext {
		public Add_OPContext add_OP() {
			return GetRuleContext<Add_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier6Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier6(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier6(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier6(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier5Context : ExprContext {
		public Mult_OPContext mult_OP() {
			return GetRuleContext<Mult_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier5Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier5(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier5(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier5(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier10Context : ExprContext {
		public Bitand_OPContext bitand_OP() {
			return GetRuleContext<Bitand_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier10Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier10(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier10(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier10(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier4Context : ExprContext {
		public Memptr_OPContext memptr_OP() {
			return GetRuleContext<Memptr_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier4Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier4(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier4(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier4(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier11Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Bitxor_OPContext bitxor_OP() {
			return GetRuleContext<Bitxor_OPContext>(0);
		}
		public Tier11Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier11(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier11(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier11(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier3Context : ExprContext {
		public SizeofExprContext sizeofExpr() {
			return GetRuleContext<SizeofExprContext>(0);
		}
		public DeleteExprContext deleteExpr() {
			return GetRuleContext<DeleteExprContext>(0);
		}
		public NewExprContext newExpr() {
			return GetRuleContext<NewExprContext>(0);
		}
		public PreOpExprContext preOpExpr() {
			return GetRuleContext<PreOpExprContext>(0);
		}
		public CastExprContext castExpr() {
			return GetRuleContext<CastExprContext>(0);
		}
		public Tier3Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier3(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier3(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier3(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier2Context : ExprContext {
		public ExprsContext exprs() {
			return GetRuleContext<ExprsContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public Post_OPContext post_OP() {
			return GetRuleContext<Post_OPContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public Mem_OPContext mem_OP() {
			return GetRuleContext<Mem_OPContext>(0);
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier2Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier2(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier2(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier12Context : ExprContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Bitor_OPContext bitor_OP() {
			return GetRuleContext<Bitor_OPContext>(0);
		}
		public Tier12Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier12(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier12(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier12(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier4_5Context : ExprContext {
		public Pow_OPContext pow_OP() {
			return GetRuleContext<Pow_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier4_5Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier4_5(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier4_5(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier4_5(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier1Context : ExprContext {
		public Scope_OPContext scope_OP() {
			return GetRuleContext<Scope_OPContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public Tier1Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier1(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier1(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier1(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier104Context : ExprContext {
		public IdOrLitContext idOrLit() {
			return GetRuleContext<IdOrLitContext>(0);
		}
		public Tier104Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier104(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier104(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier104(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Tier200Context : ExprContext {
		public ITerminalNode AUTOINDEX() { return GetToken(MyLangParser.AUTOINDEX, 0); }
		public Tier200Context(ExprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTier200(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTier200(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTier200(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		return expr(0);
	}

	private ExprContext expr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExprContext _localctx = new ExprContext(_ctx, _parentState);
		ExprContext _prevctx = _localctx;
		int _startState = 44;
		EnterRecursionRule(_localctx, 44, RULE_expr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
				{
				_localctx = new Tier16Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 190; Match(T__25);
				State = 191; expr(6);
				}
				break;

			case 2:
				{
				_localctx = new Tier3Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 197;
				switch (_input.La(1)) {
				case T__19:
				case T__0:
				case DBL_PLUS:
				case DBL_MINUS:
				case AMP:
				case STAR:
				case PLUS:
				case MINUS:
					{
					State = 192; preOpExpr();
					}
					break;
				case LPAREN:
					{
					State = 193; castExpr();
					}
					break;
				case T__18:
					{
					State = 194; sizeofExpr();
					}
					break;
				case T__22:
					{
					State = 195; newExpr();
					}
					break;
				case T__5:
					{
					State = 196; deleteExpr();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;

			case 3:
				{
				_localctx = new Tier100Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 199; Match(ID);
				State = 200; tt_exp();
				}
				break;

			case 4:
				{
				_localctx = new Tier104Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 201; idOrLit();
				}
				break;

			case 5:
				{
				_localctx = new ParenExprContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 202; Match(LPAREN);
				State = 203; expr(0);
				State = 204; Match(RPAREN);
				}
				break;

			case 6:
				{
				_localctx = new Tier200Context(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 206; Match(AUTOINDEX);
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 292;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 290;
					switch ( Interpreter.AdaptivePredict(_input,10,_ctx) ) {
					case 1:
						{
						_localctx = new Tier1Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 209;
						if (!(Precpred(_ctx, 22))) throw new FailedPredicateException(this, "Precpred(_ctx, 22)");
						State = 210; scope_OP();
						State = 211; expr(23);
						}
						break;

					case 2:
						{
						_localctx = new Tier4Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 213;
						if (!(Precpred(_ctx, 19))) throw new FailedPredicateException(this, "Precpred(_ctx, 19)");
						State = 214; memptr_OP();
						State = 215; expr(20);
						}
						break;

					case 3:
						{
						_localctx = new Tier4_5Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 217;
						if (!(Precpred(_ctx, 18))) throw new FailedPredicateException(this, "Precpred(_ctx, 18)");
						State = 218; pow_OP();
						State = 219; expr(19);
						}
						break;

					case 4:
						{
						_localctx = new Tier5Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 221;
						if (!(Precpred(_ctx, 17))) throw new FailedPredicateException(this, "Precpred(_ctx, 17)");
						State = 222; mult_OP();
						State = 223; expr(18);
						}
						break;

					case 5:
						{
						_localctx = new Tier6Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 225;
						if (!(Precpred(_ctx, 16))) throw new FailedPredicateException(this, "Precpred(_ctx, 16)");
						State = 226; add_OP();
						State = 227; expr(17);
						}
						break;

					case 6:
						{
						_localctx = new Tier7Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 229;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 230; shift_OP();
						State = 231; expr(16);
						}
						break;

					case 7:
						{
						_localctx = new Tier8Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 233;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 234; order_OP();
						State = 235; expr(15);
						}
						break;

					case 8:
						{
						_localctx = new Tier9Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 237;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 238; equal_OP();
						State = 239; expr(14);
						}
						break;

					case 9:
						{
						_localctx = new Tier10Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 241;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 242; bitand_OP();
						State = 243; expr(13);
						}
						break;

					case 10:
						{
						_localctx = new Tier11Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 245;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 246; bitxor_OP();
						State = 247; expr(12);
						}
						break;

					case 11:
						{
						_localctx = new Tier12Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 249;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 250; bitor_OP();
						State = 251; expr(11);
						}
						break;

					case 12:
						{
						_localctx = new Tier13Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 253;
						if (!(Precpred(_ctx, 9))) throw new FailedPredicateException(this, "Precpred(_ctx, 9)");
						State = 254; and_OP();
						State = 255; expr(10);
						}
						break;

					case 13:
						{
						_localctx = new Tier14Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 257;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 258; or_OP();
						State = 259; expr(9);
						}
						break;

					case 14:
						{
						_localctx = new Tier15Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 261;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 267;
						switch (_input.La(1)) {
						case T__28:
						case T__23:
						case T__17:
						case T__15:
						case T__13:
						case T__11:
						case T__9:
						case T__8:
						case T__2:
						case T__1:
						case ASSIGN:
							{
							State = 262; assign_OP();
							}
							break;
						case T__12:
							{
							State = 263; Match(T__12);
							State = 264; expr(0);
							State = 265; Match(COLON);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 269; expr(7);
						}
						break;

					case 15:
						{
						_localctx = new Tier17Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 271;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 272; Match(COMMA);
						State = 273; expr(6);
						}
						break;

					case 16:
						{
						_localctx = new Tier2Context(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 274;
						if (!(Precpred(_ctx, 21))) throw new FailedPredicateException(this, "Precpred(_ctx, 21)");
						State = 288;
						switch (_input.La(1)) {
						case DBL_PLUS:
						case DBL_MINUS:
							{
							State = 275; post_OP();
							}
							break;
						case LPAREN:
							{
							State = 276; Match(LPAREN);
							State = 278;
							_la = _input.La(1);
							if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__25) | (1L << T__22) | (1L << T__19) | (1L << T__18) | (1L << T__5) | (1L << T__0) | (1L << STRING_LIT) | (1L << CHAR_LIT) | (1L << DBL_PLUS) | (1L << DBL_MINUS) | (1L << LPAREN) | (1L << AUTOINDEX) | (1L << AMP) | (1L << STAR) | (1L << PLUS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (MINUS - 64)) | (1L << (ID - 64)) | (1L << (FLOAT_LIT - 64)) | (1L << (INTEGER_LIT - 64)))) != 0)) {
								{
								State = 277; exprs();
								}
							}

							State = 280; Match(RPAREN);
							}
							break;
						case LBRACK:
							{
							State = 281; Match(LBRACK);
							State = 282; expr(0);
							State = 283; Match(RBRACK);
							}
							break;
						case RARROW:
						case POINT:
							{
							State = 285; mem_OP();
							State = 286; Match(ID);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					}
					} 
				}
				State = 294;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExprsContext : ParserRuleContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ExprsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterExprs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitExprs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprsContext exprs() {
		ExprsContext _localctx = new ExprsContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_exprs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 295; expr(0);
			State = 300;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 296; Match(COMMA);
				State = 297; expr(0);
				}
				}
				State = 302;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tt_expContext : ParserRuleContext {
		public ExprsContext exprs() {
			return GetRuleContext<ExprsContext>(0);
		}
		public Tt_expContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tt_exp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTt_exp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTt_exp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTt_exp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tt_expContext tt_exp() {
		Tt_expContext _localctx = new Tt_expContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_tt_exp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 303; Match(LT);
			State = 304; exprs();
			State = 305; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProgContext : ParserRuleContext {
		public ToplevelContext toplevel(int i) {
			return GetRuleContext<ToplevelContext>(i);
		}
		public ToplevelContext[] toplevel() {
			return GetRuleContexts<ToplevelContext>();
		}
		public ProgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prog; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterProg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitProg(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgContext prog() {
		ProgContext _localctx = new ProgContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_prog);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 308;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 307; toplevel();
				}
				}
				State = 310;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__25) | (1L << T__22) | (1L << T__19) | (1L << T__18) | (1L << T__5) | (1L << T__0) | (1L << STRING_LIT) | (1L << CHAR_LIT) | (1L << DBL_LBRACK) | (1L << DBL_PLUS) | (1L << DBL_MINUS) | (1L << LPAREN) | (1L << AUTOINDEX) | (1L << AMP) | (1L << STAR) | (1L << PLUS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (MINUS - 64)) | (1L << (NS - 64)) | (1L << (UNION - 64)) | (1L << (CLASS - 64)) | (1L << (STRUCT - 64)) | (1L << (FUNC - 64)) | (1L << (ENUM - 64)) | (1L << (ID - 64)) | (1L << (FLOAT_LIT - 64)) | (1L << (INTEGER_LIT - 64)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ToplevelContext : ParserRuleContext {
		public ToplevelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_toplevel; } }
	 
		public ToplevelContext() { }
		public virtual void CopyFrom(ToplevelContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AttributesContext : ToplevelContext {
		public AttribContext _attrib;
		public IList<AttribContext> _attr = new List<AttribContext>();
		public ITerminalNode DBL_RBRACK() { return GetToken(MyLangParser.DBL_RBRACK, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public ITerminalNode DBL_LBRACK() { return GetToken(MyLangParser.DBL_LBRACK, 0); }
		public AttribContext attrib(int i) {
			return GetRuleContext<AttribContext>(i);
		}
		public AttribContext[] attrib() {
			return GetRuleContexts<AttribContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public AttributesContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAttributes(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAttributes(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttributes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnionDeclContext : ToplevelContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public ITerminalNode UNION() { return GetToken(MyLangParser.UNION, 0); }
		public Class_exprContext[] class_expr() {
			return GetRuleContexts<Class_exprContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public IdTplTypeContext idTplType() {
			return GetRuleContext<IdTplTypeContext>(0);
		}
		public Class_exprContext class_expr(int i) {
			return GetRuleContext<Class_exprContext>(i);
		}
		public UnionDeclContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterUnionDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitUnionDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnionDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionDeclContext : ToplevelContext {
		public Funcmeth_declContext funcmeth_decl() {
			return GetRuleContext<Funcmeth_declContext>(0);
		}
		public ITerminalNode FUNC() { return GetToken(MyLangParser.FUNC, 0); }
		public FunctionDeclContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterFunctionDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitFunctionDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StructDeclContext : ToplevelContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public ITerminalNode STRUCT() { return GetToken(MyLangParser.STRUCT, 0); }
		public Class_exprContext[] class_expr() {
			return GetRuleContexts<Class_exprContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public IdTplTypeContext idTplType() {
			return GetRuleContext<IdTplTypeContext>(0);
		}
		public Class_exprContext class_expr(int i) {
			return GetRuleContext<Class_exprContext>(i);
		}
		public StructDeclContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterStructDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitStructDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NamespaceContext : ToplevelContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public ITerminalNode SCOPE(int i) {
			return GetToken(MyLangParser.SCOPE, i);
		}
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public ITerminalNode[] ID() { return GetTokens(MyLangParser.ID); }
		public ITerminalNode[] SCOPE() { return GetTokens(MyLangParser.SCOPE); }
		public ITerminalNode NS() { return GetToken(MyLangParser.NS, 0); }
		public ToplevelContext toplevel(int i) {
			return GetRuleContext<ToplevelContext>(i);
		}
		public ToplevelContext[] toplevel() {
			return GetRuleContexts<ToplevelContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public ITerminalNode ID(int i) {
			return GetToken(MyLangParser.ID, i);
		}
		public NamespaceContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterNamespace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitNamespace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamespace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EnumDeclContext : ToplevelContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public ITerminalNode ENUM() { return GetToken(MyLangParser.ENUM, 0); }
		public Id_opt_valueContext id_opt_value(int i) {
			return GetRuleContext<Id_opt_valueContext>(i);
		}
		public Id_opt_valueContext[] id_opt_value() {
			return GetRuleContexts<Id_opt_valueContext>();
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public EnumDeclContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterEnumDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitEnumDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RestContext : ToplevelContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public RestContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterRest(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitRest(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRest(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ClassDeclContext : ToplevelContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public Class_exprContext[] class_expr() {
			return GetRuleContexts<Class_exprContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public IdTplTypeContext idTplType() {
			return GetRuleContext<IdTplTypeContext>(0);
		}
		public Class_exprContext class_expr(int i) {
			return GetRuleContext<Class_exprContext>(i);
		}
		public ITerminalNode CLASS() { return GetToken(MyLangParser.CLASS, 0); }
		public ClassDeclContext(ToplevelContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterClassDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitClassDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ToplevelContext toplevel() {
		ToplevelContext _localctx = new ToplevelContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_toplevel);
		int _la;
		try {
			int _alt;
			State = 404;
			switch ( Interpreter.AdaptivePredict(_input,23,_ctx) ) {
			case 1:
				_localctx = new AttributesContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 312; Match(DBL_LBRACK);
				State = 313; ((AttributesContext)_localctx)._attrib = attrib();
				((AttributesContext)_localctx)._attr.Add(((AttributesContext)_localctx)._attrib);
				State = 318;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 314; Match(COMMA);
					State = 315; ((AttributesContext)_localctx)._attrib = attrib();
					((AttributesContext)_localctx)._attr.Add(((AttributesContext)_localctx)._attrib);
					}
					}
					State = 320;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 321; Match(DBL_RBRACK);
				}
				break;

			case 2:
				_localctx = new NamespaceContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 323; Match(NS);
				State = 324; Match(ID);
				State = 329;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==SCOPE) {
					{
					{
					State = 325; Match(SCOPE);
					State = 326; Match(ID);
					}
					}
					State = 331;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 332; Match(SEMI);
				}
				break;

			case 3:
				_localctx = new NamespaceContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 333; Match(NS);
				State = 334; Match(ID);
				State = 339;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==SCOPE) {
					{
					{
					State = 335; Match(SCOPE);
					State = 336; Match(ID);
					}
					}
					State = 341;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 342; Match(LCURLY);
				State = 344;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 343; toplevel();
					}
					}
					State = 346;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__25) | (1L << T__22) | (1L << T__19) | (1L << T__18) | (1L << T__5) | (1L << T__0) | (1L << STRING_LIT) | (1L << CHAR_LIT) | (1L << DBL_LBRACK) | (1L << DBL_PLUS) | (1L << DBL_MINUS) | (1L << LPAREN) | (1L << AUTOINDEX) | (1L << AMP) | (1L << STAR) | (1L << PLUS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (MINUS - 64)) | (1L << (NS - 64)) | (1L << (UNION - 64)) | (1L << (CLASS - 64)) | (1L << (STRUCT - 64)) | (1L << (FUNC - 64)) | (1L << (ENUM - 64)) | (1L << (ID - 64)) | (1L << (FLOAT_LIT - 64)) | (1L << (INTEGER_LIT - 64)))) != 0) );
				State = 348; Match(RCURLY);
				}
				break;

			case 4:
				_localctx = new ClassDeclContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 350; Match(CLASS);
				State = 351; idTplType();
				State = 352; Match(LCURLY);
				State = 356;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==T__27 || _la==T__6 || ((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (METH - 98)) | (1L << (PROP - 98)) | (1L << (FIELDS - 98)) | (1L << (FIELD - 98)) | (1L << (OPERATOR - 98)))) != 0)) {
					{
					{
					State = 353; class_expr();
					}
					}
					State = 358;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 359; Match(RCURLY);
				}
				break;

			case 5:
				_localctx = new StructDeclContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 361; Match(STRUCT);
				State = 362; idTplType();
				State = 363; Match(LCURLY);
				State = 367;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==T__27 || _la==T__6 || ((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (METH - 98)) | (1L << (PROP - 98)) | (1L << (FIELDS - 98)) | (1L << (FIELD - 98)) | (1L << (OPERATOR - 98)))) != 0)) {
					{
					{
					State = 364; class_expr();
					}
					}
					State = 369;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 370; Match(RCURLY);
				}
				break;

			case 6:
				_localctx = new UnionDeclContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 372; Match(UNION);
				State = 373; idTplType();
				State = 374; Match(LCURLY);
				State = 378;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==T__27 || _la==T__6 || ((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (METH - 98)) | (1L << (PROP - 98)) | (1L << (FIELDS - 98)) | (1L << (FIELD - 98)) | (1L << (OPERATOR - 98)))) != 0)) {
					{
					{
					State = 375; class_expr();
					}
					}
					State = 380;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 381; Match(RCURLY);
				}
				break;

			case 7:
				_localctx = new EnumDeclContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 383; Match(ENUM);
				State = 384; Match(ID);
				State = 385; Match(LCURLY);
				State = 386; id_opt_value();
				State = 391;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,21,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 387; Match(COMMA);
						State = 388; id_opt_value();
						}
						} 
					}
					State = 393;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,21,_ctx);
				}
				State = 395;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 394; Match(COMMA);
					}
				}

				State = 397; Match(RCURLY);
				}
				break;

			case 8:
				_localctx = new FunctionDeclContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 399; Match(FUNC);
				State = 400; funcmeth_decl();
				}
				break;

			case 9:
				_localctx = new RestContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 401; expr(0);
				State = 402; Match(SEMI);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AttribContext : ParserRuleContext {
		public AttribContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attrib; } }
	 
		public AttribContext() { }
		public virtual void CopyFrom(AttribContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AttrPODContext : AttribContext {
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public AttrPODContext(AttribContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAttrPOD(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAttrPOD(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttrPOD(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AttrPolyContext : AttribContext {
		public AttrPolyContext(AttribContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAttrPoly(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAttrPoly(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttrPoly(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AttribContext attrib() {
		AttribContext _localctx = new AttribContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_attrib);
		int _la;
		try {
			State = 411;
			switch (_input.La(1)) {
			case T__31:
				_localctx = new AttrPolyContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 406; Match(T__31);
				}
				break;
			case T__26:
				_localctx = new AttrPODContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 407; Match(T__26);
				State = 408; Match(LPAREN);
				State = 409;
				_la = _input.La(1);
				if ( !(_la==T__30 || _la==T__7) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 410; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_opt_valueContext : ParserRuleContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode ASSIGN() { return GetToken(MyLangParser.ASSIGN, 0); }
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public Id_opt_valueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_opt_value; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterId_opt_value(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitId_opt_value(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_opt_value(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_opt_valueContext id_opt_value() {
		Id_opt_valueContext _localctx = new Id_opt_valueContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_id_opt_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 413; Match(ID);
			State = 416;
			_la = _input.La(1);
			if (_la==ASSIGN) {
				{
				State = 414; Match(ASSIGN);
				State = 415; expr(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Class_exprContext : ParserRuleContext {
		public Class_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_class_expr; } }
	 
		public Class_exprContext() { }
		public virtual void CopyFrom(Class_exprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StaticDeclContext : Class_exprContext {
		public Class_extened_exprContext class_extened_expr(int i) {
			return GetRuleContext<Class_extened_exprContext>(i);
		}
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public Class_extened_exprContext[] class_extened_expr() {
			return GetRuleContexts<Class_extened_exprContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public StaticDeclContext(Class_exprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterStaticDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitStaticDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStaticDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ClassExtendedDeclContext : Class_exprContext {
		public Class_extened_exprContext class_extened_expr() {
			return GetRuleContext<Class_extened_exprContext>(0);
		}
		public ClassExtendedDeclContext(Class_exprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterClassExtendedDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitClassExtendedDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassExtendedDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CtorDeclContext : Class_exprContext {
		public Ctor_declContext ctor_decl() {
			return GetRuleContext<Ctor_declContext>(0);
		}
		public CtorDeclContext(Class_exprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterCtorDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitCtorDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtorDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Class_exprContext class_expr() {
		Class_exprContext _localctx = new Class_exprContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_class_expr);
		int _la;
		try {
			State = 430;
			switch (_input.La(1)) {
			case T__6:
				_localctx = new StaticDeclContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 418; Match(T__6);
				State = 419; Match(LCURLY);
				State = 423;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (((((_la - 98)) & ~0x3f) == 0 && ((1L << (_la - 98)) & ((1L << (METH - 98)) | (1L << (PROP - 98)) | (1L << (FIELDS - 98)) | (1L << (FIELD - 98)) | (1L << (OPERATOR - 98)))) != 0)) {
					{
					{
					State = 420; class_extened_expr();
					}
					}
					State = 425;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 426; Match(RCURLY);
				}
				break;
			case T__27:
				_localctx = new CtorDeclContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 427; Match(T__27);
				State = 428; ctor_decl();
				}
				break;
			case METH:
			case PROP:
			case FIELDS:
			case FIELD:
			case OPERATOR:
				_localctx = new ClassExtendedDeclContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 429; class_extened_expr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Class_extened_exprContext : ParserRuleContext {
		public Funcmeth_declContext funcmeth_decl() {
			return GetRuleContext<Funcmeth_declContext>(0);
		}
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public Field_exprContext field_expr(int i) {
			return GetRuleContext<Field_exprContext>(i);
		}
		public Prop_exprContext prop_expr() {
			return GetRuleContext<Prop_exprContext>(0);
		}
		public ITerminalNode PROP() { return GetToken(MyLangParser.PROP, 0); }
		public ITerminalNode[] SEMI() { return GetTokens(MyLangParser.SEMI); }
		public ITerminalNode FIELDS() { return GetToken(MyLangParser.FIELDS, 0); }
		public Operator_declContext operator_decl() {
			return GetRuleContext<Operator_declContext>(0);
		}
		public ITerminalNode METH() { return GetToken(MyLangParser.METH, 0); }
		public ITerminalNode SEMI(int i) {
			return GetToken(MyLangParser.SEMI, i);
		}
		public ITerminalNode FIELD() { return GetToken(MyLangParser.FIELD, 0); }
		public Field_exprContext[] field_expr() {
			return GetRuleContexts<Field_exprContext>();
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public ITerminalNode OPERATOR() { return GetToken(MyLangParser.OPERATOR, 0); }
		public Class_extened_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_class_extened_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterClass_extened_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitClass_extened_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClass_extened_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Class_extened_exprContext class_extened_expr() {
		Class_extened_exprContext _localctx = new Class_extened_exprContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_class_extened_expr);
		int _la;
		try {
			State = 455;
			switch (_input.La(1)) {
			case FIELDS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 432; Match(FIELDS);
				State = 433; Match(LCURLY);
				State = 439;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (((((_la - 76)) & ~0x3f) == 0 && ((1L << (_la - 76)) & ((1L << (UNSIGNED - 76)) | (1L << (SIGNED - 76)) | (1L << (VOID - 76)) | (1L << (BOOL - 76)) | (1L << (CHAR - 76)) | (1L << (CHAR16 - 76)) | (1L << (CHAR32 - 76)) | (1L << (WCHAR - 76)) | (1L << (SHORT - 76)) | (1L << (INT - 76)) | (1L << (LONG - 76)) | (1L << (FLOAT - 76)) | (1L << (DOUBLE - 76)) | (1L << (VOLATILE - 76)) | (1L << (CONST - 76)) | (1L << (MUTABLE - 76)) | (1L << (ID - 76)))) != 0)) {
					{
					{
					State = 434; field_expr();
					State = 435; Match(SEMI);
					}
					}
					State = 441;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 442; Match(RCURLY);
				}
				break;
			case FIELD:
				EnterOuterAlt(_localctx, 2);
				{
				State = 443; Match(FIELD);
				State = 444; field_expr();
				State = 445; Match(SEMI);
				}
				break;
			case PROP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 447; Match(PROP);
				State = 448; prop_expr();
				State = 449; Match(SEMI);
				}
				break;
			case METH:
				EnterOuterAlt(_localctx, 4);
				{
				State = 451; Match(METH);
				State = 452; funcmeth_decl();
				}
				break;
			case OPERATOR:
				EnterOuterAlt(_localctx, 5);
				{
				State = 453; Match(OPERATOR);
				State = 454; operator_decl();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_exprContext : ParserRuleContext {
		public Field_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_expr; } }
	 
		public Field_exprContext() { }
		public virtual void CopyFrom(Field_exprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FieldDeclContext : Field_exprContext {
		public Id_opt_valueContext id_opt_value(int i) {
			return GetRuleContext<Id_opt_valueContext>(i);
		}
		public Id_opt_valueContext[] id_opt_value() {
			return GetRuleContexts<Id_opt_valueContext>();
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public FieldDeclContext(Field_exprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterFieldDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitFieldDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFieldDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Field_exprContext field_expr() {
		Field_exprContext _localctx = new Field_exprContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_field_expr);
		int _la;
		try {
			_localctx = new FieldDeclContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 457; anyType();
			State = 458; id_opt_value();
			State = 463;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 459; Match(COMMA);
				State = 460; id_opt_value();
				}
				}
				State = 465;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vars_declContext : ParserRuleContext {
		public Vars_declContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vars_decl; } }
	 
		public Vars_declContext() { }
		public virtual void CopyFrom(Vars_declContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class VarsDeclContext : Vars_declContext {
		public Id_opt_valueContext id_opt_value(int i) {
			return GetRuleContext<Id_opt_valueContext>(i);
		}
		public Id_opt_valueContext[] id_opt_value() {
			return GetRuleContexts<Id_opt_valueContext>();
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public VarsDeclContext(Vars_declContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterVarsDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitVarsDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarsDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Vars_declContext vars_decl() {
		Vars_declContext _localctx = new Vars_declContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_vars_decl);
		int _la;
		try {
			_localctx = new VarsDeclContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 466; anyType();
			State = 467; id_opt_value();
			State = 472;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 468; Match(COMMA);
				State = 469; id_opt_value();
				}
				}
				State = 474;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prop_exprContext : ParserRuleContext {
		public Prop_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prop_expr; } }
	 
		public Prop_exprContext() { }
		public virtual void CopyFrom(Prop_exprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PropDeclContext : Prop_exprContext {
		public Id_opt_valueContext id_opt_value(int i) {
			return GetRuleContext<Id_opt_valueContext>(i);
		}
		public Id_opt_valueContext[] id_opt_value() {
			return GetRuleContexts<Id_opt_valueContext>();
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public PropDeclContext(Prop_exprContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPropDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPropDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prop_exprContext prop_expr() {
		Prop_exprContext _localctx = new Prop_exprContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_prop_expr);
		int _la;
		try {
			_localctx = new PropDeclContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 475; anyType();
			State = 476; id_opt_value();
			State = 481;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 477; Match(COMMA);
				State = 478; id_opt_value();
				}
				}
				State = 483;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdOrLitContext : ParserRuleContext {
		public IToken arg;
		public ITerminalNode INTEGER_LIT() { return GetToken(MyLangParser.INTEGER_LIT, 0); }
		public ITerminalNode CHAR_LIT() { return GetToken(MyLangParser.CHAR_LIT, 0); }
		public ITerminalNode STRING_LIT() { return GetToken(MyLangParser.STRING_LIT, 0); }
		public ITerminalNode FLOAT_LIT() { return GetToken(MyLangParser.FLOAT_LIT, 0); }
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public IdOrLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idOrLit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIdOrLit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIdOrLit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdOrLit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdOrLitContext idOrLit() {
		IdOrLitContext _localctx = new IdOrLitContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_idOrLit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 484;
			_localctx.arg = _input.Lt(1);
			_la = _input.La(1);
			if ( !(_la==STRING_LIT || _la==CHAR_LIT || ((((_la - 110)) & ~0x3f) == 0 && ((1L << (_la - 110)) & ((1L << (ID - 110)) | (1L << (FLOAT_LIT - 110)) | (1L << (INTEGER_LIT - 110)))) != 0)) ) {
				_localctx.arg = _errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 486; anyType();
			State = 487; Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public ParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParametersContext parameters() {
		ParametersContext _localctx = new ParametersContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_parameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 489; Match(LPAREN);
			State = 498;
			_la = _input.La(1);
			if (((((_la - 76)) & ~0x3f) == 0 && ((1L << (_la - 76)) & ((1L << (UNSIGNED - 76)) | (1L << (SIGNED - 76)) | (1L << (VOID - 76)) | (1L << (BOOL - 76)) | (1L << (CHAR - 76)) | (1L << (CHAR16 - 76)) | (1L << (CHAR32 - 76)) | (1L << (WCHAR - 76)) | (1L << (SHORT - 76)) | (1L << (INT - 76)) | (1L << (LONG - 76)) | (1L << (FLOAT - 76)) | (1L << (DOUBLE - 76)) | (1L << (VOLATILE - 76)) | (1L << (CONST - 76)) | (1L << (MUTABLE - 76)) | (1L << (ID - 76)))) != 0)) {
				{
				State = 490; parameter();
				State = 495;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 491; Match(COMMA);
					State = 492; parameter();
					}
					}
					State = 497;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 500; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitializationListContext : ParserRuleContext {
		public ArgumentListContext[] argumentList() {
			return GetRuleContexts<ArgumentListContext>();
		}
		public ArgumentListContext argumentList(int i) {
			return GetRuleContext<ArgumentListContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public ITerminalNode[] ID() { return GetTokens(MyLangParser.ID); }
		public ITerminalNode COLON() { return GetToken(MyLangParser.COLON, 0); }
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public ITerminalNode ID(int i) {
			return GetToken(MyLangParser.ID, i);
		}
		public InitializationListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initializationList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterInitializationList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitInitializationList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitializationList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitializationListContext initializationList() {
		InitializationListContext _localctx = new InitializationListContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_initializationList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 502; Match(COLON);
			State = 503; Match(ID);
			State = 504; argumentList();
			State = 510;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 505; Match(COMMA);
				State = 506; Match(ID);
				State = 507; argumentList();
				}
				}
				State = 512;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public IdOrLitContext[] idOrLit() {
			return GetRuleContexts<IdOrLitContext>();
		}
		public IdOrLitContext idOrLit(int i) {
			return GetRuleContext<IdOrLitContext>(i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 513; Match(LPAREN);
			State = 522;
			_la = _input.La(1);
			if (_la==STRING_LIT || _la==CHAR_LIT || ((((_la - 110)) & ~0x3f) == 0 && ((1L << (_la - 110)) & ((1L << (ID - 110)) | (1L << (FLOAT_LIT - 110)) | (1L << (INTEGER_LIT - 110)))) != 0)) {
				{
				State = 514; idOrLit();
				State = 519;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 515; Match(COMMA);
					State = 516; idOrLit();
					}
					}
					State = 521;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 524; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ctor_declContext : ParserRuleContext {
		public Ctor_declContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ctor_decl; } }
	 
		public Ctor_declContext() { }
		public virtual void CopyFrom(Ctor_declContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CtorDefContext : Ctor_declContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public InitializationListContext initializationList() {
			return GetRuleContext<InitializationListContext>(0);
		}
		public CtorDefContext(Ctor_declContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterCtorDef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitCtorDef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtorDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ctor_declContext ctor_decl() {
		Ctor_declContext _localctx = new Ctor_declContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_ctor_decl);
		int _la;
		try {
			_localctx = new CtorDefContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 526; parameters();
			State = 528;
			_la = _input.La(1);
			if (_la==COLON) {
				{
				State = 527; initializationList();
				}
			}

			State = 530; Match(LCURLY);
			State = 531; statements();
			State = 532; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Funcmeth_declContext : ParserRuleContext {
		public Funcmeth_declContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcmeth_decl; } }
	 
		public Funcmeth_declContext() { }
		public virtual void CopyFrom(Funcmeth_declContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class FuncMethContext : Funcmeth_declContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ITerminalNode RARROW() { return GetToken(MyLangParser.RARROW, 0); }
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public FuncMethContext(Funcmeth_declContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterFuncMeth(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitFuncMeth(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncMeth(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Funcmeth_declContext funcmeth_decl() {
		Funcmeth_declContext _localctx = new Funcmeth_declContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_funcmeth_decl);
		try {
			_localctx = new FuncMethContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 545;
			switch ( Interpreter.AdaptivePredict(_input,39,_ctx) ) {
			case 1:
				{
				State = 534; anyType();
				State = 535; Match(ID);
				State = 536; parameters();
				}
				break;

			case 2:
				{
				State = 538; Match(ID);
				State = 539; parameters();
				State = 540; Match(RARROW);
				State = 541; anyType();
				}
				break;

			case 3:
				{
				State = 543; Match(ID);
				State = 544; parameters();
				}
				break;
			}
			State = 547; Match(LCURLY);
			State = 548; statements();
			State = 549; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Operator_declContext : ParserRuleContext {
		public Operator_declContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operator_decl; } }
	 
		public Operator_declContext() { }
		public virtual void CopyFrom(Operator_declContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OperatorDeclContext : Operator_declContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public ITerminalNode STRING_LIT() { return GetToken(MyLangParser.STRING_LIT, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		public ITerminalNode RARROW() { return GetToken(MyLangParser.RARROW, 0); }
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public OperatorDeclContext(Operator_declContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterOperatorDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitOperatorDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperatorDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Operator_declContext operator_decl() {
		Operator_declContext _localctx = new Operator_declContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_operator_decl);
		int _la;
		try {
			_localctx = new OperatorDeclContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 566;
			switch ( Interpreter.AdaptivePredict(_input,43,_ctx) ) {
			case 1:
				{
				State = 551; anyType();
				State = 552; Match(STRING_LIT);
				State = 554;
				_la = _input.La(1);
				if (_la==LPAREN) {
					{
					State = 553; parameters();
					}
				}

				}
				break;

			case 2:
				{
				State = 556; Match(STRING_LIT);
				State = 558;
				_la = _input.La(1);
				if (_la==LPAREN) {
					{
					State = 557; parameters();
					}
				}

				State = 560; Match(RARROW);
				State = 561; anyType();
				}
				break;

			case 3:
				{
				State = 562; Match(STRING_LIT);
				State = 564;
				_la = _input.La(1);
				if (_la==LPAREN) {
					{
					State = 563; parameters();
					}
				}

				}
				break;
			}
			State = 568; Match(LCURLY);
			State = 569; statements();
			State = 570; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 575;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__25) | (1L << T__22) | (1L << T__19) | (1L << T__18) | (1L << T__10) | (1L << T__5) | (1L << T__0) | (1L << STRING_LIT) | (1L << CHAR_LIT) | (1L << DBL_PLUS) | (1L << DBL_MINUS) | (1L << LCURLY) | (1L << LPAREN) | (1L << AUTOINDEX) | (1L << AMP) | (1L << STAR) | (1L << PLUS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (MINUS - 64)) | (1L << (CONST - 64)) | (1L << (VAR - 64)) | (1L << (FOR - 64)) | (1L << (IF - 64)) | (1L << (RETURN - 64)) | (1L << (ID - 64)) | (1L << (FLOAT_LIT - 64)) | (1L << (INTEGER_LIT - 64)))) != 0)) {
				{
				{
				State = 572; statement();
				}
				}
				State = 577;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IfStmtContext : StatementContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode IF() { return GetToken(MyLangParser.IF, 0); }
		public ITerminalNode ELSE() { return GetToken(MyLangParser.ELSE, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public IfStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIfStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIfStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionStmtContext : StatementContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public ExpressionStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterExpressionStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitExpressionStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TimesStmtContext : StatementContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ITerminalNode TIMES() { return GetToken(MyLangParser.TIMES, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public TimesStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTimesStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTimesStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimesStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclContext : StatementContext {
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public ITerminalNode VAR() { return GetToken(MyLangParser.VAR, 0); }
		public Vars_declContext vars_decl() {
			return GetRuleContext<Vars_declContext>(0);
		}
		public ITerminalNode CONST() { return GetToken(MyLangParser.CONST, 0); }
		public VariableDeclContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterVariableDecl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitVariableDecl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDecl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BreakStmtContext : StatementContext {
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public BreakStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBreakStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBreakStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBreakStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ReturnStmtContext : StatementContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode SEMI() { return GetToken(MyLangParser.SEMI, 0); }
		public ITerminalNode RETURN() { return GetToken(MyLangParser.RETURN, 0); }
		public ReturnStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterReturnStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitReturnStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BlockStmtContext : StatementContext {
		public ITerminalNode LCURLY() { return GetToken(MyLangParser.LCURLY, 0); }
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ITerminalNode RCURLY() { return GetToken(MyLangParser.RCURLY, 0); }
		public BlockStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBlockStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBlockStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EachStmtContext : StatementContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public EachStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterEachStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitEachStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEachStmt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForStmtContext : StatementContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ITerminalNode FOR() { return GetToken(MyLangParser.FOR, 0); }
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public ForStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterForStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitForStmt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_statement);
		try {
			State = 632;
			switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
			case 1:
				_localctx = new ReturnStmtContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 578; Match(RETURN);
				State = 579; expr(0);
				State = 580; Match(SEMI);
				}
				break;

			case 2:
				_localctx = new BreakStmtContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 582; Match(T__10);
				State = 583; Match(SEMI);
				}
				break;

			case 3:
				_localctx = new IfStmtContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 584; Match(IF);
				State = 585; Match(LPAREN);
				State = 586; expr(0);
				State = 587; Match(RPAREN);
				State = 588; statement();
				State = 591;
				switch ( Interpreter.AdaptivePredict(_input,45,_ctx) ) {
				case 1:
					{
					State = 589; Match(ELSE);
					State = 590; statement();
					}
					break;
				}
				}
				break;

			case 4:
				_localctx = new ForStmtContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 593; Match(FOR);
				State = 594; Match(LPAREN);
				State = 595; statement();
				State = 596; expr(0);
				State = 597; Match(SEMI);
				State = 598; expr(0);
				State = 599; Match(RPAREN);
				State = 600; statement();
				State = 603;
				switch ( Interpreter.AdaptivePredict(_input,46,_ctx) ) {
				case 1:
					{
					State = 601; Match(T__29);
					State = 602; statement();
					}
					break;
				}
				}
				break;

			case 5:
				_localctx = new TimesStmtContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 605; expr(0);
				State = 606; Match(TIMES);
				State = 608;
				switch ( Interpreter.AdaptivePredict(_input,47,_ctx) ) {
				case 1:
					{
					State = 607; Match(ID);
					}
					break;
				}
				State = 610; statement();
				}
				break;

			case 6:
				_localctx = new EachStmtContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 612; expr(0);
				State = 613; Match(DBL_POINT);
				State = 614; expr(0);
				State = 615; statement();
				}
				break;

			case 7:
				_localctx = new VariableDeclContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 617; Match(VAR);
				State = 618; vars_decl();
				State = 619; Match(SEMI);
				}
				break;

			case 8:
				_localctx = new VariableDeclContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 621; Match(CONST);
				State = 622; vars_decl();
				State = 623; Match(SEMI);
				}
				break;

			case 9:
				_localctx = new ExpressionStmtContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 625; expr(0);
				State = 626; Match(SEMI);
				}
				break;

			case 10:
				_localctx = new BlockStmtContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 628; Match(LCURLY);
				State = 629; statements();
				State = 630; Match(RCURLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnyTypeContext : ParserRuleContext {
		public AdvancedTypeContext advancedType() {
			return GetRuleContext<AdvancedTypeContext>(0);
		}
		public TypePtrContext typePtr(int i) {
			return GetRuleContext<TypePtrContext>(i);
		}
		public TypePtrContext[] typePtr() {
			return GetRuleContexts<TypePtrContext>();
		}
		public TypeQualifierContext typeQualifier(int i) {
			return GetRuleContext<TypeQualifierContext>(i);
		}
		public BasicTypeContext basicType() {
			return GetRuleContext<BasicTypeContext>(0);
		}
		public TypeQualifierContext[] typeQualifier() {
			return GetRuleContexts<TypeQualifierContext>();
		}
		public AnyTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anyType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAnyType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAnyType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyTypeContext anyType() {
		AnyTypeContext _localctx = new AnyTypeContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_anyType);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 637;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (((((_la - 90)) & ~0x3f) == 0 && ((1L << (_la - 90)) & ((1L << (VOLATILE - 90)) | (1L << (CONST - 90)) | (1L << (MUTABLE - 90)))) != 0)) {
				{
				{
				State = 634; typeQualifier();
				}
				}
				State = 639;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 642;
			switch (_input.La(1)) {
			case UNSIGNED:
			case SIGNED:
			case VOID:
			case BOOL:
			case CHAR:
			case CHAR16:
			case CHAR32:
			case WCHAR:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
				{
				State = 640; basicType();
				}
				break;
			case ID:
				{
				State = 641; advancedType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 647;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 644; typePtr();
					}
					} 
				}
				State = 649;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePtrContext : ParserRuleContext {
		public IToken ptr;
		public IToken ary;
		public ITerminalNode AT_BANG() { return GetToken(MyLangParser.AT_BANG, 0); }
		public ITerminalNode RBRACK() { return GetToken(MyLangParser.RBRACK, 0); }
		public TypeQualifierContext typeQualifier(int i) {
			return GetRuleContext<TypeQualifierContext>(i);
		}
		public ITerminalNode AT_QUEST() { return GetToken(MyLangParser.AT_QUEST, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode AMP() { return GetToken(MyLangParser.AMP, 0); }
		public ITerminalNode STAR() { return GetToken(MyLangParser.STAR, 0); }
		public TypeQualifierContext[] typeQualifier() {
			return GetRuleContexts<TypeQualifierContext>();
		}
		public ITerminalNode AT_LBRACK() { return GetToken(MyLangParser.AT_LBRACK, 0); }
		public ITerminalNode LBRACK() { return GetToken(MyLangParser.LBRACK, 0); }
		public ITerminalNode DBL_AMP() { return GetToken(MyLangParser.DBL_AMP, 0); }
		public ITerminalNode AT_PLUS() { return GetToken(MyLangParser.AT_PLUS, 0); }
		public TypePtrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePtr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTypePtr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTypePtr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypePtr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypePtrContext typePtr() {
		TypePtrContext _localctx = new TypePtrContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_typePtr);
		int _la;
		try {
			int _alt;
			State = 668;
			switch (_input.La(1)) {
			case DBL_AMP:
			case AT_BANG:
			case AT_QUEST:
			case AT_PLUS:
			case AMP:
			case STAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 650;
				_localctx.ptr = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DBL_AMP) | (1L << AT_BANG) | (1L << AT_QUEST) | (1L << AT_PLUS) | (1L << AMP) | (1L << STAR))) != 0)) ) {
					_localctx.ptr = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 654;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 651; typeQualifier();
						}
						} 
					}
					State = 656;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
				}
				}
				break;
			case AT_LBRACK:
			case LBRACK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 657;
				_localctx.ary = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==AT_LBRACK || _la==LBRACK) ) {
					_localctx.ary = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 659;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__25) | (1L << T__22) | (1L << T__19) | (1L << T__18) | (1L << T__5) | (1L << T__0) | (1L << STRING_LIT) | (1L << CHAR_LIT) | (1L << DBL_PLUS) | (1L << DBL_MINUS) | (1L << LPAREN) | (1L << AUTOINDEX) | (1L << AMP) | (1L << STAR) | (1L << PLUS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (MINUS - 64)) | (1L << (ID - 64)) | (1L << (FLOAT_LIT - 64)) | (1L << (INTEGER_LIT - 64)))) != 0)) {
					{
					State = 658; expr(0);
					}
				}

				State = 661; Match(RBRACK);
				State = 665;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,54,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 662; typeQualifier();
						}
						} 
					}
					State = 667;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,54,_ctx);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeQualifierContext : ParserRuleContext {
		public IToken qual;
		public ITerminalNode MUTABLE() { return GetToken(MyLangParser.MUTABLE, 0); }
		public ITerminalNode VOLATILE() { return GetToken(MyLangParser.VOLATILE, 0); }
		public ITerminalNode CONST() { return GetToken(MyLangParser.CONST, 0); }
		public TypeQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeQualifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterTypeQualifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitTypeQualifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeQualifierContext typeQualifier() {
		TypeQualifierContext _localctx = new TypeQualifierContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_typeQualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 670;
			_localctx.qual = _input.Lt(1);
			_la = _input.La(1);
			if ( !(((((_la - 90)) & ~0x3f) == 0 && ((1L << (_la - 90)) & ((1L << (VOLATILE - 90)) | (1L << (CONST - 90)) | (1L << (MUTABLE - 90)))) != 0)) ) {
				_localctx.qual = _errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignQualifierContext : ParserRuleContext {
		public IToken qual;
		public ITerminalNode SIGNED() { return GetToken(MyLangParser.SIGNED, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(MyLangParser.UNSIGNED, 0); }
		public SignQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signQualifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterSignQualifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitSignQualifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSignQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignQualifierContext signQualifier() {
		SignQualifierContext _localctx = new SignQualifierContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_signQualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 672;
			_localctx.qual = _input.Lt(1);
			_la = _input.La(1);
			if ( !(_la==UNSIGNED || _la==SIGNED) ) {
				_localctx.qual = _errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdvancedTypeContext : ParserRuleContext {
		public ITerminalNode SCOPE(int i) {
			return GetToken(MyLangParser.SCOPE, i);
		}
		public IdTplTypeContext idTplType(int i) {
			return GetRuleContext<IdTplTypeContext>(i);
		}
		public ITerminalNode[] SCOPE() { return GetTokens(MyLangParser.SCOPE); }
		public IdTplTypeContext[] idTplType() {
			return GetRuleContexts<IdTplTypeContext>();
		}
		public AdvancedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_advancedType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAdvancedType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAdvancedType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdvancedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdvancedTypeContext advancedType() {
		AdvancedTypeContext _localctx = new AdvancedTypeContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_advancedType);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 674; idTplType();
			State = 679;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,56,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 675; Match(SCOPE);
					State = 676; idTplType();
					}
					} 
				}
				State = 681;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,56,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdTplTypeContext : ParserRuleContext {
		public AnyTypeOrConstsContext anyTypeOrConsts() {
			return GetRuleContext<AnyTypeOrConstsContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public IdTplTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idTplType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIdTplType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIdTplType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdTplType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdTplTypeContext idTplType() {
		IdTplTypeContext _localctx = new IdTplTypeContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_idTplType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 682; Match(ID);
			State = 684;
			switch ( Interpreter.AdaptivePredict(_input,57,_ctx) ) {
			case 1:
				{
				State = 683; anyTypeOrConsts();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnyTypeOrConstsContext : ParserRuleContext {
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public AnyTypeOrConstContext[] anyTypeOrConst() {
			return GetRuleContexts<AnyTypeOrConstContext>();
		}
		public AnyTypeOrConstContext anyTypeOrConst(int i) {
			return GetRuleContext<AnyTypeOrConstContext>(i);
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public AnyTypeOrConstsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anyTypeOrConsts; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAnyTypeOrConsts(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAnyTypeOrConsts(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyTypeOrConsts(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyTypeOrConstsContext anyTypeOrConsts() {
		AnyTypeOrConstsContext _localctx = new AnyTypeOrConstsContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_anyTypeOrConsts);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 686; Match(LT);
			State = 687; anyTypeOrConst();
			State = 692;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 688; Match(COMMA);
				State = 689; anyTypeOrConst();
				}
				}
				State = 694;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 695; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnyTypeOrConstContext : ParserRuleContext {
		public ITerminalNode INTEGER_LIT() { return GetToken(MyLangParser.INTEGER_LIT, 0); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public AnyTypeOrConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anyTypeOrConst; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAnyTypeOrConst(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAnyTypeOrConst(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyTypeOrConst(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyTypeOrConstContext anyTypeOrConst() {
		AnyTypeOrConstContext _localctx = new AnyTypeOrConstContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_anyTypeOrConst);
		try {
			State = 699;
			switch (_input.La(1)) {
			case UNSIGNED:
			case SIGNED:
			case VOID:
			case BOOL:
			case CHAR:
			case CHAR16:
			case CHAR32:
			case WCHAR:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
			case VOLATILE:
			case CONST:
			case MUTABLE:
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 697; anyType();
				}
				break;
			case INTEGER_LIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 698; Match(INTEGER_LIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BasicTypeContext : ParserRuleContext {
		public ITerminalNode BOOL() { return GetToken(MyLangParser.BOOL, 0); }
		public SignQualifierContext signQualifier() {
			return GetRuleContext<SignQualifierContext>(0);
		}
		public CharacterTypeContext characterType() {
			return GetRuleContext<CharacterTypeContext>(0);
		}
		public ITerminalNode VOID() { return GetToken(MyLangParser.VOID, 0); }
		public IntegerTypeContext integerType() {
			return GetRuleContext<IntegerTypeContext>(0);
		}
		public FloatingTypeContext floatingType() {
			return GetRuleContext<FloatingTypeContext>(0);
		}
		public BasicTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_basicType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterBasicType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitBasicType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBasicType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BasicTypeContext basicType() {
		BasicTypeContext _localctx = new BasicTypeContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_basicType);
		try {
			State = 709;
			switch ( Interpreter.AdaptivePredict(_input,61,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 701; Match(VOID);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 702; Match(BOOL);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 703; characterType();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 704; floatingType();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 706;
				switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
				case 1:
					{
					State = 705; signQualifier();
					}
					break;
				}
				State = 708; integerType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharacterTypeContext : ParserRuleContext {
		public IToken chr;
		public ITerminalNode CHAR32() { return GetToken(MyLangParser.CHAR32, 0); }
		public ITerminalNode WCHAR() { return GetToken(MyLangParser.WCHAR, 0); }
		public ITerminalNode CHAR16() { return GetToken(MyLangParser.CHAR16, 0); }
		public ITerminalNode CHAR() { return GetToken(MyLangParser.CHAR, 0); }
		public CharacterTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_characterType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterCharacterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitCharacterType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacterType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CharacterTypeContext characterType() {
		CharacterTypeContext _localctx = new CharacterTypeContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_characterType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 711;
			_localctx.chr = _input.Lt(1);
			_la = _input.La(1);
			if ( !(((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (CHAR - 80)) | (1L << (CHAR16 - 80)) | (1L << (CHAR32 - 80)) | (1L << (WCHAR - 80)))) != 0)) ) {
				_localctx.chr = _errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerTypeContext : ParserRuleContext {
		public SignQualifierContext signQualifier() {
			return GetRuleContext<SignQualifierContext>(0);
		}
		public ITerminalNode INT() { return GetToken(MyLangParser.INT, 0); }
		public ITerminalNode[] LONG() { return GetTokens(MyLangParser.LONG); }
		public ITerminalNode SHORT() { return GetToken(MyLangParser.SHORT, 0); }
		public ITerminalNode LONG(int i) {
			return GetToken(MyLangParser.LONG, i);
		}
		public ITerminalNode CHAR() { return GetToken(MyLangParser.CHAR, 0); }
		public IntegerTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integerType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIntegerType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIntegerType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntegerType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntegerTypeContext integerType() {
		IntegerTypeContext _localctx = new IntegerTypeContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_integerType);
		try {
			State = 726;
			switch ( Interpreter.AdaptivePredict(_input,64,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 713; Match(CHAR);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 714; Match(SHORT);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 715; Match(LONG);
				State = 716; Match(LONG);
				State = 718;
				switch ( Interpreter.AdaptivePredict(_input,62,_ctx) ) {
				case 1:
					{
					State = 717; Match(INT);
					}
					break;
				}
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 720; Match(LONG);
				State = 722;
				switch ( Interpreter.AdaptivePredict(_input,63,_ctx) ) {
				case 1:
					{
					State = 721; Match(INT);
					}
					break;
				}
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 724; Match(INT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 725; signQualifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatingTypeContext : ParserRuleContext {
		public ITerminalNode FLOAT() { return GetToken(MyLangParser.FLOAT, 0); }
		public ITerminalNode LONG() { return GetToken(MyLangParser.LONG, 0); }
		public ITerminalNode DOUBLE() { return GetToken(MyLangParser.DOUBLE, 0); }
		public FloatingTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_floatingType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterFloatingType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitFloatingType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloatingType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FloatingTypeContext floatingType() {
		FloatingTypeContext _localctx = new FloatingTypeContext(_ctx, State);
		EnterRule(_localctx, 110, RULE_floatingType);
		try {
			State = 732;
			switch (_input.La(1)) {
			case FLOAT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 728; Match(FLOAT);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 2);
				{
				State = 729; Match(LONG);
				State = 730; Match(DOUBLE);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 731; Match(DOUBLE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnyTypeCSContext : ParserRuleContext {
		public AnyTypeContext _anyType;
		public IList<AnyTypeContext> _any_types = new List<AnyTypeContext>();
		public AnyTypeContext anyType(int i) {
			return GetRuleContext<AnyTypeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(MyLangParser.COMMA); }
		public AnyTypeContext[] anyType() {
			return GetRuleContexts<AnyTypeContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(MyLangParser.COMMA, i);
		}
		public AnyTypeCSContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anyTypeCS; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAnyTypeCS(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAnyTypeCS(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyTypeCS(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnyTypeCSContext anyTypeCS() {
		AnyTypeCSContext _localctx = new AnyTypeCSContext(_ctx, State);
		EnterRule(_localctx, 112, RULE_anyTypeCS);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 734; _localctx._anyType = anyType();
			_localctx._any_types.Add(_localctx._anyType);
			State = 739;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 735; Match(COMMA);
				State = 736; _localctx._anyType = anyType();
				_localctx._any_types.Add(_localctx._anyType);
				}
				}
				State = 741;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expr_oldContext : ParserRuleContext {
		public Expr_oldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr_old; } }
	 
		public Expr_oldContext() { }
		public virtual void CopyFrom(Expr_oldContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexExprContext : Expr_oldContext {
		public ITerminalNode RBRACK() { return GetToken(MyLangParser.RBRACK, 0); }
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode LBRACK() { return GetToken(MyLangParser.LBRACK, 0); }
		public IndexExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIndexExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIndexExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SqrtContext : Expr_oldContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode SQRT() { return GetToken(MyLangParser.SQRT, 0); }
		public SqrtContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterSqrt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitSqrt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqrt(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GreaterEqualThanContext : Expr_oldContext {
		public ITerminalNode GTEQ() { return GetToken(MyLangParser.GTEQ, 0); }
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public GreaterEqualThanContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterGreaterEqualThan(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitGreaterEqualThan(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreaterEqualThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ElementSelectExprContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode POINT() { return GetToken(MyLangParser.POINT, 0); }
		public ElementSelectExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterElementSelectExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitElementSelectExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementSelectExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AssignContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ITerminalNode ASSIGN() { return GetToken(MyLangParser.ASSIGN, 0); }
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public AssignContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAssign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAssign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NopExprContext : Expr_oldContext {
		public NopExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterNopExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitNopExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNopExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LessThanContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ITerminalNode LT() { return GetToken(MyLangParser.LT, 0); }
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public LessThanContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterLessThan(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitLessThan(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLessThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FuncCallExprContext : Expr_oldContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode ID() { return GetToken(MyLangParser.ID, 0); }
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public FuncCallExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterFuncCallExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitFuncCallExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncCallExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreCrementExprContext : Expr_oldContext {
		public IToken op;
		public ITerminalNode DBL_PLUS() { return GetToken(MyLangParser.DBL_PLUS, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode DBL_MINUS() { return GetToken(MyLangParser.DBL_MINUS, 0); }
		public PreCrementExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPreCrementExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPreCrementExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreCrementExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddSubContext : Expr_oldContext {
		public IToken op;
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ITerminalNode MINUS() { return GetToken(MyLangParser.MINUS, 0); }
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(MyLangParser.PLUS, 0); }
		public AddSubContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterAddSub(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitAddSub(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddSub(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParensExprContext : Expr_oldContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public ParensExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterParensExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitParensExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParensExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryMinusContext : Expr_oldContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public UnaryMinusContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterUnaryMinus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitUnaryMinus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PostCrementExprContext : Expr_oldContext {
		public IToken op;
		public ITerminalNode DBL_PLUS() { return GetToken(MyLangParser.DBL_PLUS, 0); }
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode DBL_MINUS() { return GetToken(MyLangParser.DBL_MINUS, 0); }
		public PostCrementExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPostCrementExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPostCrementExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostCrementExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RShiftContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public RShiftContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterRShift(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitRShift(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotEqualContext : Expr_oldContext {
		public ITerminalNode NEQ() { return GetToken(MyLangParser.NEQ, 0); }
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public NotEqualContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterNotEqual(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitNotEqual(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GreaterThanContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode GT() { return GetToken(MyLangParser.GT, 0); }
		public GreaterThanContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterGreaterThan(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitGreaterThan(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreaterThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EqualContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode EQ() { return GetToken(MyLangParser.EQ, 0); }
		public EqualContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterEqual(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitEqual(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MulDivModContext : Expr_oldContext {
		public IToken op;
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode STAR() { return GetToken(MyLangParser.STAR, 0); }
		public ITerminalNode MOD() { return GetToken(MyLangParser.MOD, 0); }
		public ITerminalNode SLASH() { return GetToken(MyLangParser.SLASH, 0); }
		public MulDivModContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterMulDivMod(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitMulDivMod(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulDivMod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LShiftContext : Expr_oldContext {
		public IToken op;
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode LSHIFT() { return GetToken(MyLangParser.LSHIFT, 0); }
		public LShiftContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterLShift(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitLShift(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LessEqualThanContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode LTEQ() { return GetToken(MyLangParser.LTEQ, 0); }
		public LessEqualThanContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterLessEqualThan(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitLessEqualThan(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLessEqualThan(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StaticCastExprContext : Expr_oldContext {
		public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(MyLangParser.RPAREN, 0); }
		public AnyTypeContext anyType() {
			return GetRuleContext<AnyTypeContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(MyLangParser.LPAREN, 0); }
		public StaticCastExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterStaticCastExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitStaticCastExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStaticCastExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowContext : Expr_oldContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode[] STAR() { return GetTokens(MyLangParser.STAR); }
		public ITerminalNode STAR(int i) {
			return GetToken(MyLangParser.STAR, i);
		}
		public PowContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterPow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitPow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IdOrLitExprContext : Expr_oldContext {
		public IdOrLitContext idOrLit() {
			return GetRuleContext<IdOrLitContext>(0);
		}
		public IdOrLitExprContext(Expr_oldContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterIdOrLitExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitIdOrLitExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdOrLitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expr_oldContext expr_old() {
		Expr_oldContext _localctx = new Expr_oldContext(_ctx, State);
		EnterRule(_localctx, 114, RULE_expr_old);
		int _la;
		try {
			State = 827;
			switch ( Interpreter.AdaptivePredict(_input,67,_ctx) ) {
			case 1:
				_localctx = new StaticCastExprContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 742; Match(LPAREN);
				State = 743; anyType();
				State = 744; Match(RPAREN);
				State = 745; expr(0);
				}
				break;

			case 2:
				_localctx = new PostCrementExprContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 747; expr(0);
				State = 748;
				((PostCrementExprContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==DBL_PLUS || _la==DBL_MINUS) ) {
					((PostCrementExprContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;

			case 3:
				_localctx = new IndexExprContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 750; expr(0);
				State = 751; Match(LBRACK);
				State = 752; expr(0);
				State = 753; Match(RBRACK);
				}
				break;

			case 4:
				_localctx = new FuncCallExprContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 755; Match(ID);
				State = 756; Match(LPAREN);
				State = 757; expr(0);
				State = 758; Match(RPAREN);
				}
				break;

			case 5:
				_localctx = new ElementSelectExprContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 760; expr(0);
				State = 761; Match(POINT);
				State = 762; expr(0);
				}
				break;

			case 6:
				_localctx = new PreCrementExprContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 764;
				((PreCrementExprContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==DBL_PLUS || _la==DBL_MINUS) ) {
					((PreCrementExprContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 765; expr(0);
				}
				break;

			case 7:
				_localctx = new PowContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 766; expr(0);
				State = 767; Match(STAR);
				State = 768; Match(STAR);
				State = 769; expr(0);
				}
				break;

			case 8:
				_localctx = new SqrtContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 771; Match(SQRT);
				State = 772; expr(0);
				}
				break;

			case 9:
				_localctx = new MulDivModContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 773; expr(0);
				State = 774;
				((MulDivModContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STAR) | (1L << SLASH) | (1L << MOD))) != 0)) ) {
					((MulDivModContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 775; expr(0);
				}
				break;

			case 10:
				_localctx = new AddSubContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 777; expr(0);
				State = 778;
				((AddSubContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
					((AddSubContext)_localctx).op = _errHandler.RecoverInline(this);
				}
				Consume();
				State = 779; expr(0);
				}
				break;

			case 11:
				_localctx = new LShiftContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 781; expr(0);
				State = 782; ((LShiftContext)_localctx).op = Match(LSHIFT);
				State = 783; expr(0);
				}
				break;

			case 12:
				_localctx = new RShiftContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 785; expr(0);
				{
				State = 786; Match(GT);
				State = 787; Match(GT);
				}
				State = 789; expr(0);
				}
				break;

			case 13:
				_localctx = new EqualContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 791; expr(0);
				State = 792; Match(EQ);
				State = 793; expr(0);
				}
				break;

			case 14:
				_localctx = new NotEqualContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 795; expr(0);
				State = 796; Match(NEQ);
				State = 797; expr(0);
				}
				break;

			case 15:
				_localctx = new LessEqualThanContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 799; expr(0);
				State = 800; Match(LTEQ);
				State = 801; expr(0);
				}
				break;

			case 16:
				_localctx = new GreaterEqualThanContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 803; expr(0);
				State = 804; Match(GTEQ);
				State = 805; expr(0);
				}
				break;

			case 17:
				_localctx = new LessThanContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 807; expr(0);
				State = 808; Match(LT);
				State = 809; expr(0);
				}
				break;

			case 18:
				_localctx = new GreaterThanContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 811; expr(0);
				State = 812; Match(GT);
				State = 813; expr(0);
				}
				break;

			case 19:
				_localctx = new AssignContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 815; expr(0);
				State = 816; Match(ASSIGN);
				State = 817; expr(0);
				}
				break;

			case 20:
				_localctx = new UnaryMinusContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 819; Match(MINUS);
				State = 820; expr(0);
				}
				break;

			case 21:
				_localctx = new ParensExprContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 821; Match(LPAREN);
				State = 822; expr(0);
				State = 823; Match(RPAREN);
				}
				break;

			case 22:
				_localctx = new NopExprContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 825; Match(T__21);
				}
				break;

			case 23:
				_localctx = new IdOrLitExprContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 826; idOrLit();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentContext : ParserRuleContext {
		public ITerminalNode COMMENT() { return GetToken(MyLangParser.COMMENT, 0); }
		public CommentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.EnterComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMyLangListener typedListener = listener as IMyLangListener;
			if (typedListener != null) typedListener.ExitComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMyLangVisitor<TResult> typedVisitor = visitor as IMyLangVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentContext comment() {
		CommentContext _localctx = new CommentContext(_ctx, State);
		EnterRule(_localctx, 116, RULE_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 829; Match(COMMENT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 22: return expr_sempred((ExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expr_sempred(ExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 22);

		case 1: return Precpred(_ctx, 19);

		case 2: return Precpred(_ctx, 18);

		case 3: return Precpred(_ctx, 17);

		case 4: return Precpred(_ctx, 16);

		case 5: return Precpred(_ctx, 15);

		case 6: return Precpred(_ctx, 14);

		case 7: return Precpred(_ctx, 13);

		case 8: return Precpred(_ctx, 12);

		case 9: return Precpred(_ctx, 11);

		case 10: return Precpred(_ctx, 10);

		case 11: return Precpred(_ctx, 9);

		case 12: return Precpred(_ctx, 8);

		case 13: return Precpred(_ctx, 7);

		case 14: return Precpred(_ctx, 5);

		case 15: return Precpred(_ctx, 21);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3v\x342\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x4\x39\t\x39\x4:\t:\x4;\t;\x4<\t<\x3\x2\x3\x2\x3\x3\x3\x3"+
		"\x3\x4\x3\x4\x3\x5\x3\x5\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\t\x3\t\x3"+
		"\t\x5\t\x8A\n\t\x3\n\x3\n\x3\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3\xE\x3\xE\x3"+
		"\xF\x3\xF\x3\x10\x3\x10\x3\x11\x3\x11\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13"+
		"\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x15"+
		"\x3\x15\x3\x15\x5\x15\xAD\n\x15\x3\x16\x3\x16\x5\x16\xB1\n\x16\x3\x16"+
		"\x3\x16\x3\x16\x3\x16\x5\x16\xB7\n\x16\x3\x17\x3\x17\x3\x17\x5\x17\xBC"+
		"\n\x17\x3\x17\x3\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x5\x18\xC8\n\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3"+
		"\x18\x3\x18\x5\x18\xD2\n\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x5\x18\x10E\n\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3"+
		"\x18\x3\x18\x3\x18\x3\x18\x5\x18\x119\n\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x123\n\x18\a\x18\x125\n\x18\f\x18"+
		"\xE\x18\x128\v\x18\x3\x19\x3\x19\x3\x19\a\x19\x12D\n\x19\f\x19\xE\x19"+
		"\x130\v\x19\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1B\x6\x1B\x137\n\x1B\r\x1B"+
		"\xE\x1B\x138\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x13F\n\x1C\f\x1C\xE\x1C"+
		"\x142\v\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x14A\n\x1C"+
		"\f\x1C\xE\x1C\x14D\v\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x154"+
		"\n\x1C\f\x1C\xE\x1C\x157\v\x1C\x3\x1C\x3\x1C\x6\x1C\x15B\n\x1C\r\x1C\xE"+
		"\x1C\x15C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x165\n\x1C\f"+
		"\x1C\xE\x1C\x168\v\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C"+
		"\x170\n\x1C\f\x1C\xE\x1C\x173\v\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C"+
		"\x3\x1C\a\x1C\x17B\n\x1C\f\x1C\xE\x1C\x17E\v\x1C\x3\x1C\x3\x1C\x3\x1C"+
		"\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\a\x1C\x188\n\x1C\f\x1C\xE\x1C\x18B"+
		"\v\x1C\x3\x1C\x5\x1C\x18E\n\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3"+
		"\x1C\x3\x1C\x5\x1C\x197\n\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x5\x1D"+
		"\x19E\n\x1D\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x1A3\n\x1E\x3\x1F\x3\x1F\x3\x1F"+
		"\a\x1F\x1A8\n\x1F\f\x1F\xE\x1F\x1AB\v\x1F\x3\x1F\x3\x1F\x3\x1F\x3\x1F"+
		"\x5\x1F\x1B1\n\x1F\x3 \x3 \x3 \x3 \x3 \a \x1B8\n \f \xE \x1BB\v \x3 \x3"+
		" \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x3 \x5 \x1CA\n \x3!\x3!\x3!"+
		"\x3!\a!\x1D0\n!\f!\xE!\x1D3\v!\x3\"\x3\"\x3\"\x3\"\a\"\x1D9\n\"\f\"\xE"+
		"\"\x1DC\v\"\x3#\x3#\x3#\x3#\a#\x1E2\n#\f#\xE#\x1E5\v#\x3$\x3$\x3%\x3%"+
		"\x3%\x3&\x3&\x3&\x3&\a&\x1F0\n&\f&\xE&\x1F3\v&\x5&\x1F5\n&\x3&\x3&\x3"+
		"\'\x3\'\x3\'\x3\'\x3\'\x3\'\a\'\x1FF\n\'\f\'\xE\'\x202\v\'\x3(\x3(\x3"+
		"(\x3(\a(\x208\n(\f(\xE(\x20B\v(\x5(\x20D\n(\x3(\x3(\x3)\x3)\x5)\x213\n"+
		")\x3)\x3)\x3)\x3)\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x3*\x5*\x224"+
		"\n*\x3*\x3*\x3*\x3*\x3+\x3+\x3+\x5+\x22D\n+\x3+\x3+\x5+\x231\n+\x3+\x3"+
		"+\x3+\x3+\x5+\x237\n+\x5+\x239\n+\x3+\x3+\x3+\x3+\x3,\a,\x240\n,\f,\xE"+
		",\x243\v,\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x5-\x252"+
		"\n-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x5-\x25E\n-\x3-\x3-\x3-\x5"+
		"-\x263\n-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x3-"+
		"\x3-\x3-\x3-\x3-\x3-\x3-\x3-\x5-\x27B\n-\x3.\a.\x27E\n.\f.\xE.\x281\v"+
		".\x3.\x3.\x5.\x285\n.\x3.\a.\x288\n.\f.\xE.\x28B\v.\x3/\x3/\a/\x28F\n"+
		"/\f/\xE/\x292\v/\x3/\x3/\x5/\x296\n/\x3/\x3/\a/\x29A\n/\f/\xE/\x29D\v"+
		"/\x5/\x29F\n/\x3\x30\x3\x30\x3\x31\x3\x31\x3\x32\x3\x32\x3\x32\a\x32\x2A8"+
		"\n\x32\f\x32\xE\x32\x2AB\v\x32\x3\x33\x3\x33\x5\x33\x2AF\n\x33\x3\x34"+
		"\x3\x34\x3\x34\x3\x34\a\x34\x2B5\n\x34\f\x34\xE\x34\x2B8\v\x34\x3\x34"+
		"\x3\x34\x3\x35\x3\x35\x5\x35\x2BE\n\x35\x3\x36\x3\x36\x3\x36\x3\x36\x3"+
		"\x36\x5\x36\x2C5\n\x36\x3\x36\x5\x36\x2C8\n\x36\x3\x37\x3\x37\x3\x38\x3"+
		"\x38\x3\x38\x3\x38\x3\x38\x5\x38\x2D1\n\x38\x3\x38\x3\x38\x5\x38\x2D5"+
		"\n\x38\x3\x38\x3\x38\x5\x38\x2D9\n\x38\x3\x39\x3\x39\x3\x39\x3\x39\x5"+
		"\x39\x2DF\n\x39\x3:\x3:\x3:\a:\x2E4\n:\f:\xE:\x2E7\v:\x3;\x3;\x3;\x3;"+
		"\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3"+
		";\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;"+
		"\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3"+
		";\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;"+
		"\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x3;\x5;\x33E\n;\x3<\x3<\x3<\x2"+
		"\x2\x3.=\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16"+
		"\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2"+
		"\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2"+
		"J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x66\x2"+
		"h\x2j\x2l\x2n\x2p\x2r\x2t\x2v\x2\x2\x12\x3\x2,-\a\x2\xF\xF\"\",-=>\x41"+
		"\x42\v\x2\x6\x6\v\v\x11\x11\x13\x13\x15\x15\x17\x17\x19\x1A !MM\x3\x2"+
		">@\x3\x2\x41\x42\x4\x2..\x46\x46\x4\x2\n\n\x12\x12\x3\x2IL\x3\x2GH\x4"+
		"\x2\x4\x4\x1B\x1B\x4\x2$%pr\x5\x2++\x31\x33=>\x3\x2\x34\x35\x3\x2\\^\x3"+
		"\x2NO\x3\x2RU\x393\x2x\x3\x2\x2\x2\x4z\x3\x2\x2\x2\x6|\x3\x2\x2\x2\b~"+
		"\x3\x2\x2\x2\n\x80\x3\x2\x2\x2\f\x82\x3\x2\x2\x2\xE\x84\x3\x2\x2\x2\x10"+
		"\x89\x3\x2\x2\x2\x12\x8B\x3\x2\x2\x2\x14\x8D\x3\x2\x2\x2\x16\x8F\x3\x2"+
		"\x2\x2\x18\x91\x3\x2\x2\x2\x1A\x93\x3\x2\x2\x2\x1C\x95\x3\x2\x2\x2\x1E"+
		"\x97\x3\x2\x2\x2 \x99\x3\x2\x2\x2\"\x9B\x3\x2\x2\x2$\x9D\x3\x2\x2\x2&"+
		"\xA0\x3\x2\x2\x2(\xAC\x3\x2\x2\x2*\xAE\x3\x2\x2\x2,\xB8\x3\x2\x2\x2.\xD1"+
		"\x3\x2\x2\x2\x30\x129\x3\x2\x2\x2\x32\x131\x3\x2\x2\x2\x34\x136\x3\x2"+
		"\x2\x2\x36\x196\x3\x2\x2\x2\x38\x19D\x3\x2\x2\x2:\x19F\x3\x2\x2\x2<\x1B0"+
		"\x3\x2\x2\x2>\x1C9\x3\x2\x2\x2@\x1CB\x3\x2\x2\x2\x42\x1D4\x3\x2\x2\x2"+
		"\x44\x1DD\x3\x2\x2\x2\x46\x1E6\x3\x2\x2\x2H\x1E8\x3\x2\x2\x2J\x1EB\x3"+
		"\x2\x2\x2L\x1F8\x3\x2\x2\x2N\x203\x3\x2\x2\x2P\x210\x3\x2\x2\x2R\x223"+
		"\x3\x2\x2\x2T\x238\x3\x2\x2\x2V\x241\x3\x2\x2\x2X\x27A\x3\x2\x2\x2Z\x27F"+
		"\x3\x2\x2\x2\\\x29E\x3\x2\x2\x2^\x2A0\x3\x2\x2\x2`\x2A2\x3\x2\x2\x2\x62"+
		"\x2A4\x3\x2\x2\x2\x64\x2AC\x3\x2\x2\x2\x66\x2B0\x3\x2\x2\x2h\x2BD\x3\x2"+
		"\x2\x2j\x2C7\x3\x2\x2\x2l\x2C9\x3\x2\x2\x2n\x2D8\x3\x2\x2\x2p\x2DE\x3"+
		"\x2\x2\x2r\x2E0\x3\x2\x2\x2t\x33D\x3\x2\x2\x2v\x33F\x3\x2\x2\x2xy\a\x30"+
		"\x2\x2y\x3\x3\x2\x2\x2z{\t\x2\x2\x2{\x5\x3\x2\x2\x2|}\t\x3\x2\x2}\a\x3"+
		"\x2\x2\x2~\x7F\t\x4\x2\x2\x7F\t\x3\x2\x2\x2\x80\x81\a\x14\x2\x2\x81\v"+
		"\x3\x2\x2\x2\x82\x83\t\x5\x2\x2\x83\r\x3\x2\x2\x2\x84\x85\t\x6\x2\x2\x85"+
		"\xF\x3\x2\x2\x2\x86\x8A\a/\x2\x2\x87\x88\aL\x2\x2\x88\x8A\aL\x2\x2\x89"+
		"\x86\x3\x2\x2\x2\x89\x87\x3\x2\x2\x2\x8A\x11\x3\x2\x2\x2\x8B\x8C\a=\x2"+
		"\x2\x8C\x13\x3\x2\x2\x2\x8D\x8E\a\x1E\x2\x2\x8E\x15\x3\x2\x2\x2\x8F\x90"+
		"\a\xE\x2\x2\x90\x17\x3\x2\x2\x2\x91\x92\a+\x2\x2\x92\x19\x3\x2\x2\x2\x93"+
		"\x94\a\x1F\x2\x2\x94\x1B\x3\x2\x2\x2\x95\x96\t\a\x2\x2\x96\x1D\x3\x2\x2"+
		"\x2\x97\x98\t\b\x2\x2\x98\x1F\x3\x2\x2\x2\x99\x9A\t\t\x2\x2\x9A!\x3\x2"+
		"\x2\x2\x9B\x9C\t\n\x2\x2\x9C#\x3\x2\x2\x2\x9D\x9E\x5\x6\x4\x2\x9E\x9F"+
		"\x5.\x18\x2\x9F%\x3\x2\x2\x2\xA0\xA1\a\x39\x2\x2\xA1\xA2\x5Z.\x2\xA2\xA3"+
		"\a:\x2\x2\xA3\xA4\x5.\x18\x2\xA4\'\x3\x2\x2\x2\xA5\xA6\a\x10\x2\x2\xA6"+
		"\xAD\x5.\x18\x2\xA7\xA8\a\x10\x2\x2\xA8\xA9\a\x39\x2\x2\xA9\xAA\x5.\x18"+
		"\x2\xAA\xAB\a:\x2\x2\xAB\xAD\x3\x2\x2\x2\xAC\xA5\x3\x2\x2\x2\xAC\xA7\x3"+
		"\x2\x2\x2\xAD)\x3\x2\x2\x2\xAE\xB0\a\f\x2\x2\xAF\xB1\x5Z.\x2\xB0\xAF\x3"+
		"\x2\x2\x2\xB0\xB1\x3\x2\x2\x2\xB1\xB6\x3\x2\x2\x2\xB2\xB3\a\x39\x2\x2"+
		"\xB3\xB4\x5\x30\x19\x2\xB4\xB5\a:\x2\x2\xB5\xB7\x3\x2\x2\x2\xB6\xB2\x3"+
		"\x2\x2\x2\xB6\xB7\x3\x2\x2\x2\xB7+\x3\x2\x2\x2\xB8\xBB\a\x1D\x2\x2\xB9"+
		"\xBA\a\x35\x2\x2\xBA\xBC\a\x36\x2\x2\xBB\xB9\x3\x2\x2\x2\xBB\xBC\x3\x2"+
		"\x2\x2\xBC\xBD\x3\x2\x2\x2\xBD\xBE\x5.\x18\x2\xBE-\x3\x2\x2\x2\xBF\xC0"+
		"\b\x18\x1\x2\xC0\xC1\a\t\x2\x2\xC1\xD2\x5.\x18\b\xC2\xC8\x5$\x13\x2\xC3"+
		"\xC8\x5&\x14\x2\xC4\xC8\x5(\x15\x2\xC5\xC8\x5*\x16\x2\xC6\xC8\x5,\x17"+
		"\x2\xC7\xC2\x3\x2\x2\x2\xC7\xC3\x3\x2\x2\x2\xC7\xC4\x3\x2\x2\x2\xC7\xC5"+
		"\x3\x2\x2\x2\xC7\xC6\x3\x2\x2\x2\xC8\xD2\x3\x2\x2\x2\xC9\xCA\ap\x2\x2"+
		"\xCA\xD2\x5\x32\x1A\x2\xCB\xD2\x5\x46$\x2\xCC\xCD\a\x39\x2\x2\xCD\xCE"+
		"\x5.\x18\x2\xCE\xCF\a:\x2\x2\xCF\xD2\x3\x2\x2\x2\xD0\xD2\a;\x2\x2\xD1"+
		"\xBF\x3\x2\x2\x2\xD1\xC7\x3\x2\x2\x2\xD1\xC9\x3\x2\x2\x2\xD1\xCB\x3\x2"+
		"\x2\x2\xD1\xCC\x3\x2\x2\x2\xD1\xD0\x3\x2\x2\x2\xD2\x126\x3\x2\x2\x2\xD3"+
		"\xD4\f\x18\x2\x2\xD4\xD5\x5\x2\x2\x2\xD5\xD6\x5.\x18\x19\xD6\x125\x3\x2"+
		"\x2\x2\xD7\xD8\f\x15\x2\x2\xD8\xD9\x5\x1E\x10\x2\xD9\xDA\x5.\x18\x16\xDA"+
		"\x125\x3\x2\x2\x2\xDB\xDC\f\x14\x2\x2\xDC\xDD\x5\n\x6\x2\xDD\xDE\x5.\x18"+
		"\x15\xDE\x125\x3\x2\x2\x2\xDF\xE0\f\x13\x2\x2\xE0\xE1\x5\f\a\x2\xE1\xE2"+
		"\x5.\x18\x14\xE2\x125\x3\x2\x2\x2\xE3\xE4\f\x12\x2\x2\xE4\xE5\x5\xE\b"+
		"\x2\xE5\xE6\x5.\x18\x13\xE6\x125\x3\x2\x2\x2\xE7\xE8\f\x11\x2\x2\xE8\xE9"+
		"\x5\x10\t\x2\xE9\xEA\x5.\x18\x12\xEA\x125\x3\x2\x2\x2\xEB\xEC\f\x10\x2"+
		"\x2\xEC\xED\x5 \x11\x2\xED\xEE\x5.\x18\x11\xEE\x125\x3\x2\x2\x2\xEF\xF0"+
		"\f\xF\x2\x2\xF0\xF1\x5\"\x12\x2\xF1\xF2\x5.\x18\x10\xF2\x125\x3\x2\x2"+
		"\x2\xF3\xF4\f\xE\x2\x2\xF4\xF5\x5\x12\n\x2\xF5\xF6\x5.\x18\xF\xF6\x125"+
		"\x3\x2\x2\x2\xF7\xF8\f\r\x2\x2\xF8\xF9\x5\x14\v\x2\xF9\xFA\x5.\x18\xE"+
		"\xFA\x125\x3\x2\x2\x2\xFB\xFC\f\f\x2\x2\xFC\xFD\x5\x16\f\x2\xFD\xFE\x5"+
		".\x18\r\xFE\x125\x3\x2\x2\x2\xFF\x100\f\v\x2\x2\x100\x101\x5\x18\r\x2"+
		"\x101\x102\x5.\x18\f\x102\x125\x3\x2\x2\x2\x103\x104\f\n\x2\x2\x104\x105"+
		"\x5\x1A\xE\x2\x105\x106\x5.\x18\v\x106\x125\x3\x2\x2\x2\x107\x10D\f\t"+
		"\x2\x2\x108\x10E\x5\b\x5\x2\x109\x10A\a\x16\x2\x2\x10A\x10B\x5.\x18\x2"+
		"\x10B\x10C\a\x44\x2\x2\x10C\x10E\x3\x2\x2\x2\x10D\x108\x3\x2\x2\x2\x10D"+
		"\x109\x3\x2\x2\x2\x10E\x10F\x3\x2\x2\x2\x10F\x110\x5.\x18\t\x110\x125"+
		"\x3\x2\x2\x2\x111\x112\f\a\x2\x2\x112\x113\a\x45\x2\x2\x113\x125\x5.\x18"+
		"\b\x114\x122\f\x17\x2\x2\x115\x123\x5\x4\x3\x2\x116\x118\a\x39\x2\x2\x117"+
		"\x119\x5\x30\x19\x2\x118\x117\x3\x2\x2\x2\x118\x119\x3\x2\x2\x2\x119\x11A"+
		"\x3\x2\x2\x2\x11A\x123\a:\x2\x2\x11B\x11C\a\x35\x2\x2\x11C\x11D\x5.\x18"+
		"\x2\x11D\x11E\a\x36\x2\x2\x11E\x123\x3\x2\x2\x2\x11F\x120\x5\x1C\xF\x2"+
		"\x120\x121\ap\x2\x2\x121\x123\x3\x2\x2\x2\x122\x115\x3\x2\x2\x2\x122\x116"+
		"\x3\x2\x2\x2\x122\x11B\x3\x2\x2\x2\x122\x11F\x3\x2\x2\x2\x123\x125\x3"+
		"\x2\x2\x2\x124\xD3\x3\x2\x2\x2\x124\xD7\x3\x2\x2\x2\x124\xDB\x3\x2\x2"+
		"\x2\x124\xDF\x3\x2\x2\x2\x124\xE3\x3\x2\x2\x2\x124\xE7\x3\x2\x2\x2\x124"+
		"\xEB\x3\x2\x2\x2\x124\xEF\x3\x2\x2\x2\x124\xF3\x3\x2\x2\x2\x124\xF7\x3"+
		"\x2\x2\x2\x124\xFB\x3\x2\x2\x2\x124\xFF\x3\x2\x2\x2\x124\x103\x3\x2\x2"+
		"\x2\x124\x107\x3\x2\x2\x2\x124\x111\x3\x2\x2\x2\x124\x114\x3\x2\x2\x2"+
		"\x125\x128\x3\x2\x2\x2\x126\x124\x3\x2\x2\x2\x126\x127\x3\x2\x2\x2\x127"+
		"/\x3\x2\x2\x2\x128\x126\x3\x2\x2\x2\x129\x12E\x5.\x18\x2\x12A\x12B\a\x45"+
		"\x2\x2\x12B\x12D\x5.\x18\x2\x12C\x12A\x3\x2\x2\x2\x12D\x130\x3\x2\x2\x2"+
		"\x12E\x12C\x3\x2\x2\x2\x12E\x12F\x3\x2\x2\x2\x12F\x31\x3\x2\x2\x2\x130"+
		"\x12E\x3\x2\x2\x2\x131\x132\aK\x2\x2\x132\x133\x5\x30\x19\x2\x133\x134"+
		"\aL\x2\x2\x134\x33\x3\x2\x2\x2\x135\x137\x5\x36\x1C\x2\x136\x135\x3\x2"+
		"\x2\x2\x137\x138\x3\x2\x2\x2\x138\x136\x3\x2\x2\x2\x138\x139\x3\x2\x2"+
		"\x2\x139\x35\x3\x2\x2\x2\x13A\x13B\a)\x2\x2\x13B\x140\x5\x38\x1D\x2\x13C"+
		"\x13D\a\x45\x2\x2\x13D\x13F\x5\x38\x1D\x2\x13E\x13C\x3\x2\x2\x2\x13F\x142"+
		"\x3\x2\x2\x2\x140\x13E\x3\x2\x2\x2\x140\x141\x3\x2\x2\x2\x141\x143\x3"+
		"\x2\x2\x2\x142\x140\x3\x2\x2\x2\x143\x144\a*\x2\x2\x144\x197\x3\x2\x2"+
		"\x2\x145\x146\a[\x2\x2\x146\x14B\ap\x2\x2\x147\x148\a\x30\x2\x2\x148\x14A"+
		"\ap\x2\x2\x149\x147\x3\x2\x2\x2\x14A\x14D\x3\x2\x2\x2\x14B\x149\x3\x2"+
		"\x2\x2\x14B\x14C\x3\x2\x2\x2\x14C\x14E\x3\x2\x2\x2\x14D\x14B\x3\x2\x2"+
		"\x2\x14E\x197\a\x43\x2\x2\x14F\x150\a[\x2\x2\x150\x155\ap\x2\x2\x151\x152"+
		"\a\x30\x2\x2\x152\x154\ap\x2\x2\x153\x151\x3\x2\x2\x2\x154\x157\x3\x2"+
		"\x2\x2\x155\x153\x3\x2\x2\x2\x155\x156\x3\x2\x2\x2\x156\x158\x3\x2\x2"+
		"\x2\x157\x155\x3\x2\x2\x2\x158\x15A\a\x37\x2\x2\x159\x15B\x5\x36\x1C\x2"+
		"\x15A\x159\x3\x2\x2\x2\x15B\x15C\x3\x2\x2\x2\x15C\x15A\x3\x2\x2\x2\x15C"+
		"\x15D\x3\x2\x2\x2\x15D\x15E\x3\x2\x2\x2\x15E\x15F\a\x38\x2\x2\x15F\x197"+
		"\x3\x2\x2\x2\x160\x161\a\x61\x2\x2\x161\x162\x5\x64\x33\x2\x162\x166\a"+
		"\x37\x2\x2\x163\x165\x5<\x1F\x2\x164\x163\x3\x2\x2\x2\x165\x168\x3\x2"+
		"\x2\x2\x166\x164\x3\x2\x2\x2\x166\x167\x3\x2\x2\x2\x167\x169\x3\x2\x2"+
		"\x2\x168\x166\x3\x2\x2\x2\x169\x16A\a\x38\x2\x2\x16A\x197\x3\x2\x2\x2"+
		"\x16B\x16C\a\x62\x2\x2\x16C\x16D\x5\x64\x33\x2\x16D\x171\a\x37\x2\x2\x16E"+
		"\x170\x5<\x1F\x2\x16F\x16E\x3\x2\x2\x2\x170\x173\x3\x2\x2\x2\x171\x16F"+
		"\x3\x2\x2\x2\x171\x172\x3\x2\x2\x2\x172\x174\x3\x2\x2\x2\x173\x171\x3"+
		"\x2\x2\x2\x174\x175\a\x38\x2\x2\x175\x197\x3\x2\x2\x2\x176\x177\a`\x2"+
		"\x2\x177\x178\x5\x64\x33\x2\x178\x17C\a\x37\x2\x2\x179\x17B\x5<\x1F\x2"+
		"\x17A\x179\x3\x2\x2\x2\x17B\x17E\x3\x2\x2\x2\x17C\x17A\x3\x2\x2\x2\x17C"+
		"\x17D\x3\x2\x2\x2\x17D\x17F\x3\x2\x2\x2\x17E\x17C\x3\x2\x2\x2\x17F\x180"+
		"\a\x38\x2\x2\x180\x197\x3\x2\x2\x2\x181\x182\a\x65\x2\x2\x182\x183\ap"+
		"\x2\x2\x183\x184\a\x37\x2\x2\x184\x189\x5:\x1E\x2\x185\x186\a\x45\x2\x2"+
		"\x186\x188\x5:\x1E\x2\x187\x185\x3\x2\x2\x2\x188\x18B\x3\x2\x2\x2\x189"+
		"\x187\x3\x2\x2\x2\x189\x18A\x3\x2\x2\x2\x18A\x18D\x3\x2\x2\x2\x18B\x189"+
		"\x3\x2\x2\x2\x18C\x18E\a\x45\x2\x2\x18D\x18C\x3\x2\x2\x2\x18D\x18E\x3"+
		"\x2\x2\x2\x18E\x18F\x3\x2\x2\x2\x18F\x190\a\x38\x2\x2\x190\x197\x3\x2"+
		"\x2\x2\x191\x192\a\x63\x2\x2\x192\x197\x5R*\x2\x193\x194\x5.\x18\x2\x194"+
		"\x195\a\x43\x2\x2\x195\x197\x3\x2\x2\x2\x196\x13A\x3\x2\x2\x2\x196\x145"+
		"\x3\x2\x2\x2\x196\x14F\x3\x2\x2\x2\x196\x160\x3\x2\x2\x2\x196\x16B\x3"+
		"\x2\x2\x2\x196\x176\x3\x2\x2\x2\x196\x181\x3\x2\x2\x2\x196\x191\x3\x2"+
		"\x2\x2\x196\x193\x3\x2\x2\x2\x197\x37\x3\x2\x2\x2\x198\x19E\a\x3\x2\x2"+
		"\x199\x19A\a\b\x2\x2\x19A\x19B\a\x39\x2\x2\x19B\x19C\t\v\x2\x2\x19C\x19E"+
		"\a:\x2\x2\x19D\x198\x3\x2\x2\x2\x19D\x199\x3\x2\x2\x2\x19E\x39\x3\x2\x2"+
		"\x2\x19F\x1A2\ap\x2\x2\x1A0\x1A1\aM\x2\x2\x1A1\x1A3\x5.\x18\x2\x1A2\x1A0"+
		"\x3\x2\x2\x2\x1A2\x1A3\x3\x2\x2\x2\x1A3;\x3\x2\x2\x2\x1A4\x1A5\a\x1C\x2"+
		"\x2\x1A5\x1A9\a\x37\x2\x2\x1A6\x1A8\x5> \x2\x1A7\x1A6\x3\x2\x2\x2\x1A8"+
		"\x1AB\x3\x2\x2\x2\x1A9\x1A7\x3\x2\x2\x2\x1A9\x1AA\x3\x2\x2\x2\x1AA\x1AC"+
		"\x3\x2\x2\x2\x1AB\x1A9\x3\x2\x2\x2\x1AC\x1B1\a\x38\x2\x2\x1AD\x1AE\a\a"+
		"\x2\x2\x1AE\x1B1\x5P)\x2\x1AF\x1B1\x5> \x2\x1B0\x1A4\x3\x2\x2\x2\x1B0"+
		"\x1AD\x3\x2\x2\x2\x1B0\x1AF\x3\x2\x2\x2\x1B1=\x3\x2\x2\x2\x1B2\x1B3\a"+
		"g\x2\x2\x1B3\x1B9\a\x37\x2\x2\x1B4\x1B5\x5@!\x2\x1B5\x1B6\a\x43\x2\x2"+
		"\x1B6\x1B8\x3\x2\x2\x2\x1B7\x1B4\x3\x2\x2\x2\x1B8\x1BB\x3\x2\x2\x2\x1B9"+
		"\x1B7\x3\x2\x2\x2\x1B9\x1BA\x3\x2\x2\x2\x1BA\x1BC\x3\x2\x2\x2\x1BB\x1B9"+
		"\x3\x2\x2\x2\x1BC\x1CA\a\x38\x2\x2\x1BD\x1BE\ah\x2\x2\x1BE\x1BF\x5@!\x2"+
		"\x1BF\x1C0\a\x43\x2\x2\x1C0\x1CA\x3\x2\x2\x2\x1C1\x1C2\a\x66\x2\x2\x1C2"+
		"\x1C3\x5\x44#\x2\x1C3\x1C4\a\x43\x2\x2\x1C4\x1CA\x3\x2\x2\x2\x1C5\x1C6"+
		"\a\x64\x2\x2\x1C6\x1CA\x5R*\x2\x1C7\x1C8\ai\x2\x2\x1C8\x1CA\x5T+\x2\x1C9"+
		"\x1B2\x3\x2\x2\x2\x1C9\x1BD\x3\x2\x2\x2\x1C9\x1C1\x3\x2\x2\x2\x1C9\x1C5"+
		"\x3\x2\x2\x2\x1C9\x1C7\x3\x2\x2\x2\x1CA?\x3\x2\x2\x2\x1CB\x1CC\x5Z.\x2"+
		"\x1CC\x1D1\x5:\x1E\x2\x1CD\x1CE\a\x45\x2\x2\x1CE\x1D0\x5:\x1E\x2\x1CF"+
		"\x1CD\x3\x2\x2\x2\x1D0\x1D3\x3\x2\x2\x2\x1D1\x1CF\x3\x2\x2\x2\x1D1\x1D2"+
		"\x3\x2\x2\x2\x1D2\x41\x3\x2\x2\x2\x1D3\x1D1\x3\x2\x2\x2\x1D4\x1D5\x5Z"+
		".\x2\x1D5\x1DA\x5:\x1E\x2\x1D6\x1D7\a\x45\x2\x2\x1D7\x1D9\x5:\x1E\x2\x1D8"+
		"\x1D6\x3\x2\x2\x2\x1D9\x1DC\x3\x2\x2\x2\x1DA\x1D8\x3\x2\x2\x2\x1DA\x1DB"+
		"\x3\x2\x2\x2\x1DB\x43\x3\x2\x2\x2\x1DC\x1DA\x3\x2\x2\x2\x1DD\x1DE\x5Z"+
		".\x2\x1DE\x1E3\x5:\x1E\x2\x1DF\x1E0\a\x45\x2\x2\x1E0\x1E2\x5:\x1E\x2\x1E1"+
		"\x1DF\x3\x2\x2\x2\x1E2\x1E5\x3\x2\x2\x2\x1E3\x1E1\x3\x2\x2\x2\x1E3\x1E4"+
		"\x3\x2\x2\x2\x1E4\x45\x3\x2\x2\x2\x1E5\x1E3\x3\x2\x2\x2\x1E6\x1E7\t\f"+
		"\x2\x2\x1E7G\x3\x2\x2\x2\x1E8\x1E9\x5Z.\x2\x1E9\x1EA\ap\x2\x2\x1EAI\x3"+
		"\x2\x2\x2\x1EB\x1F4\a\x39\x2\x2\x1EC\x1F1\x5H%\x2\x1ED\x1EE\a\x45\x2\x2"+
		"\x1EE\x1F0\x5H%\x2\x1EF\x1ED\x3\x2\x2\x2\x1F0\x1F3\x3\x2\x2\x2\x1F1\x1EF"+
		"\x3\x2\x2\x2\x1F1\x1F2\x3\x2\x2\x2\x1F2\x1F5\x3\x2\x2\x2\x1F3\x1F1\x3"+
		"\x2\x2\x2\x1F4\x1EC\x3\x2\x2\x2\x1F4\x1F5\x3\x2\x2\x2\x1F5\x1F6\x3\x2"+
		"\x2\x2\x1F6\x1F7\a:\x2\x2\x1F7K\x3\x2\x2\x2\x1F8\x1F9\a\x44\x2\x2\x1F9"+
		"\x1FA\ap\x2\x2\x1FA\x200\x5N(\x2\x1FB\x1FC\a\x45\x2\x2\x1FC\x1FD\ap\x2"+
		"\x2\x1FD\x1FF\x5N(\x2\x1FE\x1FB\x3\x2\x2\x2\x1FF\x202\x3\x2\x2\x2\x200"+
		"\x1FE\x3\x2\x2\x2\x200\x201\x3\x2\x2\x2\x201M\x3\x2\x2\x2\x202\x200\x3"+
		"\x2\x2\x2\x203\x20C\a\x39\x2\x2\x204\x209\x5\x46$\x2\x205\x206\a\x45\x2"+
		"\x2\x206\x208\x5\x46$\x2\x207\x205\x3\x2\x2\x2\x208\x20B\x3\x2\x2\x2\x209"+
		"\x207\x3\x2\x2\x2\x209\x20A\x3\x2\x2\x2\x20A\x20D\x3\x2\x2\x2\x20B\x209"+
		"\x3\x2\x2\x2\x20C\x204\x3\x2\x2\x2\x20C\x20D\x3\x2\x2\x2\x20D\x20E\x3"+
		"\x2\x2\x2\x20E\x20F\a:\x2\x2\x20FO\x3\x2\x2\x2\x210\x212\x5J&\x2\x211"+
		"\x213\x5L\'\x2\x212\x211\x3\x2\x2\x2\x212\x213\x3\x2\x2\x2\x213\x214\x3"+
		"\x2\x2\x2\x214\x215\a\x37\x2\x2\x215\x216\x5V,\x2\x216\x217\a\x38\x2\x2"+
		"\x217Q\x3\x2\x2\x2\x218\x219\x5Z.\x2\x219\x21A\ap\x2\x2\x21A\x21B\x5J"+
		"&\x2\x21B\x224\x3\x2\x2\x2\x21C\x21D\ap\x2\x2\x21D\x21E\x5J&\x2\x21E\x21F"+
		"\a.\x2\x2\x21F\x220\x5Z.\x2\x220\x224\x3\x2\x2\x2\x221\x222\ap\x2\x2\x222"+
		"\x224\x5J&\x2\x223\x218\x3\x2\x2\x2\x223\x21C\x3\x2\x2\x2\x223\x221\x3"+
		"\x2\x2\x2\x224\x225\x3\x2\x2\x2\x225\x226\a\x37\x2\x2\x226\x227\x5V,\x2"+
		"\x227\x228\a\x38\x2\x2\x228S\x3\x2\x2\x2\x229\x22A\x5Z.\x2\x22A\x22C\a"+
		"$\x2\x2\x22B\x22D\x5J&\x2\x22C\x22B\x3\x2\x2\x2\x22C\x22D\x3\x2\x2\x2"+
		"\x22D\x239\x3\x2\x2\x2\x22E\x230\a$\x2\x2\x22F\x231\x5J&\x2\x230\x22F"+
		"\x3\x2\x2\x2\x230\x231\x3\x2\x2\x2\x231\x232\x3\x2\x2\x2\x232\x233\a."+
		"\x2\x2\x233\x239\x5Z.\x2\x234\x236\a$\x2\x2\x235\x237\x5J&\x2\x236\x235"+
		"\x3\x2\x2\x2\x236\x237\x3\x2\x2\x2\x237\x239\x3\x2\x2\x2\x238\x229\x3"+
		"\x2\x2\x2\x238\x22E\x3\x2\x2\x2\x238\x234\x3\x2\x2\x2\x239\x23A\x3\x2"+
		"\x2\x2\x23A\x23B\a\x37\x2\x2\x23B\x23C\x5V,\x2\x23C\x23D\a\x38\x2\x2\x23D"+
		"U\x3\x2\x2\x2\x23E\x240\x5X-\x2\x23F\x23E\x3\x2\x2\x2\x240\x243\x3\x2"+
		"\x2\x2\x241\x23F\x3\x2\x2\x2\x241\x242\x3\x2\x2\x2\x242W\x3\x2\x2\x2\x243"+
		"\x241\x3\x2\x2\x2\x244\x245\ao\x2\x2\x245\x246\x5.\x18\x2\x246\x247\a"+
		"\x43\x2\x2\x247\x27B\x3\x2\x2\x2\x248\x249\a\x18\x2\x2\x249\x27B\a\x43"+
		"\x2\x2\x24A\x24B\am\x2\x2\x24B\x24C\a\x39\x2\x2\x24C\x24D\x5.\x18\x2\x24D"+
		"\x24E\a:\x2\x2\x24E\x251\x5X-\x2\x24F\x250\an\x2\x2\x250\x252\x5X-\x2"+
		"\x251\x24F\x3\x2\x2\x2\x251\x252\x3\x2\x2\x2\x252\x27B\x3\x2\x2\x2\x253"+
		"\x254\ak\x2\x2\x254\x255\a\x39\x2\x2\x255\x256\x5X-\x2\x256\x257\x5.\x18"+
		"\x2\x257\x258\a\x43\x2\x2\x258\x259\x5.\x18\x2\x259\x25A\a:\x2\x2\x25A"+
		"\x25D\x5X-\x2\x25B\x25C\a\x5\x2\x2\x25C\x25E\x5X-\x2\x25D\x25B\x3\x2\x2"+
		"\x2\x25D\x25E\x3\x2\x2\x2\x25E\x27B\x3\x2\x2\x2\x25F\x260\x5.\x18\x2\x260"+
		"\x262\al\x2\x2\x261\x263\ap\x2\x2\x262\x261\x3\x2\x2\x2\x262\x263\x3\x2"+
		"\x2\x2\x263\x264\x3\x2\x2\x2\x264\x265\x5X-\x2\x265\x27B\x3\x2\x2\x2\x266"+
		"\x267\x5.\x18\x2\x267\x268\a(\x2\x2\x268\x269\x5.\x18\x2\x269\x26A\x5"+
		"X-\x2\x26A\x27B\x3\x2\x2\x2\x26B\x26C\aj\x2\x2\x26C\x26D\x5\x42\"\x2\x26D"+
		"\x26E\a\x43\x2\x2\x26E\x27B\x3\x2\x2\x2\x26F\x270\a]\x2\x2\x270\x271\x5"+
		"\x42\"\x2\x271\x272\a\x43\x2\x2\x272\x27B\x3\x2\x2\x2\x273\x274\x5.\x18"+
		"\x2\x274\x275\a\x43\x2\x2\x275\x27B\x3\x2\x2\x2\x276\x277\a\x37\x2\x2"+
		"\x277\x278\x5V,\x2\x278\x279\a\x38\x2\x2\x279\x27B\x3\x2\x2\x2\x27A\x244"+
		"\x3\x2\x2\x2\x27A\x248\x3\x2\x2\x2\x27A\x24A\x3\x2\x2\x2\x27A\x253\x3"+
		"\x2\x2\x2\x27A\x25F\x3\x2\x2\x2\x27A\x266\x3\x2\x2\x2\x27A\x26B\x3\x2"+
		"\x2\x2\x27A\x26F\x3\x2\x2\x2\x27A\x273\x3\x2\x2\x2\x27A\x276\x3\x2\x2"+
		"\x2\x27BY\x3\x2\x2\x2\x27C\x27E\x5^\x30\x2\x27D\x27C\x3\x2\x2\x2\x27E"+
		"\x281\x3\x2\x2\x2\x27F\x27D\x3\x2\x2\x2\x27F\x280\x3\x2\x2\x2\x280\x284"+
		"\x3\x2\x2\x2\x281\x27F\x3\x2\x2\x2\x282\x285\x5j\x36\x2\x283\x285\x5\x62"+
		"\x32\x2\x284\x282\x3\x2\x2\x2\x284\x283\x3\x2\x2\x2\x285\x289\x3\x2\x2"+
		"\x2\x286\x288\x5\\/\x2\x287\x286\x3\x2\x2\x2\x288\x28B\x3\x2\x2\x2\x289"+
		"\x287\x3\x2\x2\x2\x289\x28A\x3\x2\x2\x2\x28A[\x3\x2\x2\x2\x28B\x289\x3"+
		"\x2\x2\x2\x28C\x290\t\r\x2\x2\x28D\x28F\x5^\x30\x2\x28E\x28D\x3\x2\x2"+
		"\x2\x28F\x292\x3\x2\x2\x2\x290\x28E\x3\x2\x2\x2\x290\x291\x3\x2\x2\x2"+
		"\x291\x29F\x3\x2\x2\x2\x292\x290\x3\x2\x2\x2\x293\x295\t\xE\x2\x2\x294"+
		"\x296\x5.\x18\x2\x295\x294\x3\x2\x2\x2\x295\x296\x3\x2\x2\x2\x296\x297"+
		"\x3\x2\x2\x2\x297\x29B\a\x36\x2\x2\x298\x29A\x5^\x30\x2\x299\x298\x3\x2"+
		"\x2\x2\x29A\x29D\x3\x2\x2\x2\x29B\x299\x3\x2\x2\x2\x29B\x29C\x3\x2\x2"+
		"\x2\x29C\x29F\x3\x2\x2\x2\x29D\x29B\x3\x2\x2\x2\x29E\x28C\x3\x2\x2\x2"+
		"\x29E\x293\x3\x2\x2\x2\x29F]\x3\x2\x2\x2\x2A0\x2A1\t\xF\x2\x2\x2A1_\x3"+
		"\x2\x2\x2\x2A2\x2A3\t\x10\x2\x2\x2A3\x61\x3\x2\x2\x2\x2A4\x2A9\x5\x64"+
		"\x33\x2\x2A5\x2A6\a\x30\x2\x2\x2A6\x2A8\x5\x64\x33\x2\x2A7\x2A5\x3\x2"+
		"\x2\x2\x2A8\x2AB\x3\x2\x2\x2\x2A9\x2A7\x3\x2\x2\x2\x2A9\x2AA\x3\x2\x2"+
		"\x2\x2AA\x63\x3\x2\x2\x2\x2AB\x2A9\x3\x2\x2\x2\x2AC\x2AE\ap\x2\x2\x2AD"+
		"\x2AF\x5\x66\x34\x2\x2AE\x2AD\x3\x2\x2\x2\x2AE\x2AF\x3\x2\x2\x2\x2AF\x65"+
		"\x3\x2\x2\x2\x2B0\x2B1\aK\x2\x2\x2B1\x2B6\x5h\x35\x2\x2B2\x2B3\a\x45\x2"+
		"\x2\x2B3\x2B5\x5h\x35\x2\x2B4\x2B2\x3\x2\x2\x2\x2B5\x2B8\x3\x2\x2\x2\x2B6"+
		"\x2B4\x3\x2\x2\x2\x2B6\x2B7\x3\x2\x2\x2\x2B7\x2B9\x3\x2\x2\x2\x2B8\x2B6"+
		"\x3\x2\x2\x2\x2B9\x2BA\aL\x2\x2\x2BAg\x3\x2\x2\x2\x2BB\x2BE\x5Z.\x2\x2BC"+
		"\x2BE\ar\x2\x2\x2BD\x2BB\x3\x2\x2\x2\x2BD\x2BC\x3\x2\x2\x2\x2BEi\x3\x2"+
		"\x2\x2\x2BF\x2C8\aP\x2\x2\x2C0\x2C8\aQ\x2\x2\x2C1\x2C8\x5l\x37\x2\x2C2"+
		"\x2C8\x5p\x39\x2\x2C3\x2C5\x5`\x31\x2\x2C4\x2C3\x3\x2\x2\x2\x2C4\x2C5"+
		"\x3\x2\x2\x2\x2C5\x2C6\x3\x2\x2\x2\x2C6\x2C8\x5n\x38\x2\x2C7\x2BF\x3\x2"+
		"\x2\x2\x2C7\x2C0\x3\x2\x2\x2\x2C7\x2C1\x3\x2\x2\x2\x2C7\x2C2\x3\x2\x2"+
		"\x2\x2C7\x2C4\x3\x2\x2\x2\x2C8k\x3\x2\x2\x2\x2C9\x2CA\t\x11\x2\x2\x2CA"+
		"m\x3\x2\x2\x2\x2CB\x2D9\aR\x2\x2\x2CC\x2D9\aV\x2\x2\x2CD\x2CE\aX\x2\x2"+
		"\x2CE\x2D0\aX\x2\x2\x2CF\x2D1\aW\x2\x2\x2D0\x2CF\x3\x2\x2\x2\x2D0\x2D1"+
		"\x3\x2\x2\x2\x2D1\x2D9\x3\x2\x2\x2\x2D2\x2D4\aX\x2\x2\x2D3\x2D5\aW\x2"+
		"\x2\x2D4\x2D3\x3\x2\x2\x2\x2D4\x2D5\x3\x2\x2\x2\x2D5\x2D9\x3\x2\x2\x2"+
		"\x2D6\x2D9\aW\x2\x2\x2D7\x2D9\x5`\x31\x2\x2D8\x2CB\x3\x2\x2\x2\x2D8\x2CC"+
		"\x3\x2\x2\x2\x2D8\x2CD\x3\x2\x2\x2\x2D8\x2D2\x3\x2\x2\x2\x2D8\x2D6\x3"+
		"\x2\x2\x2\x2D8\x2D7\x3\x2\x2\x2\x2D9o\x3\x2\x2\x2\x2DA\x2DF\aY\x2\x2\x2DB"+
		"\x2DC\aX\x2\x2\x2DC\x2DF\aZ\x2\x2\x2DD\x2DF\aZ\x2\x2\x2DE\x2DA\x3\x2\x2"+
		"\x2\x2DE\x2DB\x3\x2\x2\x2\x2DE\x2DD\x3\x2\x2\x2\x2DFq\x3\x2\x2\x2\x2E0"+
		"\x2E5\x5Z.\x2\x2E1\x2E2\a\x45\x2\x2\x2E2\x2E4\x5Z.\x2\x2E3\x2E1\x3\x2"+
		"\x2\x2\x2E4\x2E7\x3\x2\x2\x2\x2E5\x2E3\x3\x2\x2\x2\x2E5\x2E6\x3\x2\x2"+
		"\x2\x2E6s\x3\x2\x2\x2\x2E7\x2E5\x3\x2\x2\x2\x2E8\x2E9\a\x39\x2\x2\x2E9"+
		"\x2EA\x5Z.\x2\x2EA\x2EB\a:\x2\x2\x2EB\x2EC\x5.\x18\x2\x2EC\x33E\x3\x2"+
		"\x2\x2\x2ED\x2EE\x5.\x18\x2\x2EE\x2EF\t\x2\x2\x2\x2EF\x33E\x3\x2\x2\x2"+
		"\x2F0\x2F1\x5.\x18\x2\x2F1\x2F2\a\x35\x2\x2\x2F2\x2F3\x5.\x18\x2\x2F3"+
		"\x2F4\a\x36\x2\x2\x2F4\x33E\x3\x2\x2\x2\x2F5\x2F6\ap\x2\x2\x2F6\x2F7\a"+
		"\x39\x2\x2\x2F7\x2F8\x5.\x18\x2\x2F8\x2F9\a:\x2\x2\x2F9\x33E\x3\x2\x2"+
		"\x2\x2FA\x2FB\x5.\x18\x2\x2FB\x2FC\a\x46\x2\x2\x2FC\x2FD\x5.\x18\x2\x2FD"+
		"\x33E\x3\x2\x2\x2\x2FE\x2FF\t\x2\x2\x2\x2FF\x33E\x5.\x18\x2\x300\x301"+
		"\x5.\x18\x2\x301\x302\a>\x2\x2\x302\x303\a>\x2\x2\x303\x304\x5.\x18\x2"+
		"\x304\x33E\x3\x2\x2\x2\x305\x306\a_\x2\x2\x306\x33E\x5.\x18\x2\x307\x308"+
		"\x5.\x18\x2\x308\x309\t\x5\x2\x2\x309\x30A\x5.\x18\x2\x30A\x33E\x3\x2"+
		"\x2\x2\x30B\x30C\x5.\x18\x2\x30C\x30D\t\x6\x2\x2\x30D\x30E\x5.\x18\x2"+
		"\x30E\x33E\x3\x2\x2\x2\x30F\x310\x5.\x18\x2\x310\x311\a/\x2\x2\x311\x312"+
		"\x5.\x18\x2\x312\x33E\x3\x2\x2\x2\x313\x314\x5.\x18\x2\x314\x315\aL\x2"+
		"\x2\x315\x316\aL\x2\x2\x316\x317\x3\x2\x2\x2\x317\x318\x5.\x18\x2\x318"+
		"\x33E\x3\x2\x2\x2\x319\x31A\x5.\x18\x2\x31A\x31B\aG\x2\x2\x31B\x31C\x5"+
		".\x18\x2\x31C\x33E\x3\x2\x2\x2\x31D\x31E\x5.\x18\x2\x31E\x31F\aH\x2\x2"+
		"\x31F\x320\x5.\x18\x2\x320\x33E\x3\x2\x2\x2\x321\x322\x5.\x18\x2\x322"+
		"\x323\aI\x2\x2\x323\x324\x5.\x18\x2\x324\x33E\x3\x2\x2\x2\x325\x326\x5"+
		".\x18\x2\x326\x327\aJ\x2\x2\x327\x328\x5.\x18\x2\x328\x33E\x3\x2\x2\x2"+
		"\x329\x32A\x5.\x18\x2\x32A\x32B\aK\x2\x2\x32B\x32C\x5.\x18\x2\x32C\x33E"+
		"\x3\x2\x2\x2\x32D\x32E\x5.\x18\x2\x32E\x32F\aL\x2\x2\x32F\x330\x5.\x18"+
		"\x2\x330\x33E\x3\x2\x2\x2\x331\x332\x5.\x18\x2\x332\x333\aM\x2\x2\x333"+
		"\x334\x5.\x18\x2\x334\x33E\x3\x2\x2\x2\x335\x336\a\x42\x2\x2\x336\x33E"+
		"\x5.\x18\x2\x337\x338\a\x39\x2\x2\x338\x339\x5.\x18\x2\x339\x33A\a:\x2"+
		"\x2\x33A\x33E\x3\x2\x2\x2\x33B\x33E\a\r\x2\x2\x33C\x33E\x5\x46$\x2\x33D"+
		"\x2E8\x3\x2\x2\x2\x33D\x2ED\x3\x2\x2\x2\x33D\x2F0\x3\x2\x2\x2\x33D\x2F5"+
		"\x3\x2\x2\x2\x33D\x2FA\x3\x2\x2\x2\x33D\x2FE\x3\x2\x2\x2\x33D\x300\x3"+
		"\x2\x2\x2\x33D\x305\x3\x2\x2\x2\x33D\x307\x3\x2\x2\x2\x33D\x30B\x3\x2"+
		"\x2\x2\x33D\x30F\x3\x2\x2\x2\x33D\x313\x3\x2\x2\x2\x33D\x319\x3\x2\x2"+
		"\x2\x33D\x31D\x3\x2\x2\x2\x33D\x321\x3\x2\x2\x2\x33D\x325\x3\x2\x2\x2"+
		"\x33D\x329\x3\x2\x2\x2\x33D\x32D\x3\x2\x2\x2\x33D\x331\x3\x2\x2\x2\x33D"+
		"\x335\x3\x2\x2\x2\x33D\x337\x3\x2\x2\x2\x33D\x33B\x3\x2\x2\x2\x33D\x33C"+
		"\x3\x2\x2\x2\x33Eu\x3\x2\x2\x2\x33F\x340\a#\x2\x2\x340w\x3\x2\x2\x2\x46"+
		"\x89\xAC\xB0\xB6\xBB\xC7\xD1\x10D\x118\x122\x124\x126\x12E\x138\x140\x14B"+
		"\x155\x15C\x166\x171\x17C\x189\x18D\x196\x19D\x1A2\x1A9\x1B0\x1B9\x1C9"+
		"\x1D1\x1DA\x1E3\x1F1\x1F4\x200\x209\x20C\x212\x223\x22C\x230\x236\x238"+
		"\x241\x251\x25D\x262\x27A\x27F\x284\x289\x290\x295\x29B\x29E\x2A9\x2AE"+
		"\x2B6\x2BD\x2C4\x2C7\x2D0\x2D4\x2D8\x2DE\x2E5\x33D";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace MyLang
